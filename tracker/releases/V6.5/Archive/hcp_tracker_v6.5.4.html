<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HCP Portfolio Tracker v6.5.4 - Regret Minimization Framework</title>
    <!--
    HCP PORTFOLIO TRACKER v6.5.4 - REGRET MINIMIZATION FRAMEWORK INTEGRATION
    File: hcp_tracker_v6.5.4_regret_minimization.html
    Last Updated: 2025-09-02 21:30:00 UTC
    
    NEW IN v6.5.4:
    - PortfolioOptimizer v2.0 with sophisticated regret minimization
    - 6-step portfolio optimization process per IPS v3.10
    - Dual optimization: Œ± √ó Max_Regret + (1-Œ±) √ó Weighted_Regret
    - Smart hedging protocols with correlation assessment
    - Complete 12-asset security universe (VTI, VEA, VWO, SMH, SRVR, PIMIX, PYLD, GLD, COM, IGF, DBMF, SWVXX)
    - Security-specific trading rules (PIMIX hold-only, PYLD primary income)
    
    PRESERVED FROM v6.5.3:
    - Steps 1-4 fully functional (NO REGRESSIONS)
    - TrackerCore v1.0 architecture maintained
    - DataEditor modal system preserved
    - ThemeCalculator v2.9 with 16-scenario matrix
    - FileHandler v1.5 sample data generation
    - Single-file deployment maintained
    - All navigation and state persistence
    -->
    <style>
        /* Base styles - Same as v6.5.3 - NO CHANGES TO PRESERVE FUNCTIONALITY */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; color: #333;
        }
        .container {
            background: white; border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1400px; margin: 0 auto; overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 30px; text-align: center;
        }
        .progress-bar {
            background: rgba(255,255,255,0.2); padding: 20px;
            display: flex; justify-content: space-between; flex-wrap: wrap; gap: 10px;
        }
        .step-indicator {
            flex: 1; min-width: 80px; text-align: center; cursor: pointer;
            padding: 10px; border-radius: 8px; transition: all 0.3s;
        }
        .step-indicator.completed { background: rgba(255,255,255,0.3); }
        .step-indicator.active { background: #ffc107; color: #333; }
        .step-indicator.locked { opacity: 0.5; cursor: not-allowed; }
        .navigation {
            background: #f8f9fa; padding: 20px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #dee2e6;
        }
        .nav-button {
            background: #667eea; color: white; border: none;
            padding: 10px 20px; border-radius: 6px; cursor: pointer;
            font-size: 16px; transition: background 0.3s;
        }
        .nav-button:hover:not(:disabled) { background: #5a67d8; }
        .nav-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .content { padding: 30px; min-height: 400px; }
        .step-content { display: none; }
        .step-content.active { display: block; }
        
        /* Status and theme styles - PRESERVED */
        .status-good { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-error { color: #dc3545; }
        .theme-analysis-v651 { max-width: 1000px; margin: 0 auto; }
        .theme-item { background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .theme-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .theme-name { font-size: 1.2em; font-weight: bold; color: #333; }
        .theme-percentage { font-size: 1.5em; font-weight: bold; color: #667eea; }
        .theme-bar { height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden; }
        .theme-fill { height: 100%; transition: width 0.5s ease; }

        /* Scenario matrix styles - PRESERVED */
        .scenario-matrix { max-width: 1200px; margin: 0 auto; }
        .scenario-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 20px; }
        .scenario-card { background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); transition: transform 0.2s; }
        .scenario-card:hover { transform: translateY(-2px); }
        .scenario-rank { font-size: 0.9em; color: #666; margin-bottom: 5px; }
        .scenario-name { font-weight: bold; font-size: 1.1em; margin-bottom: 8px; color: #333; }
        .scenario-probability { font-size: 1.3em; font-weight: bold; margin-bottom: 8px; }
        .scenario-binary { font-family: monospace; font-size: 0.8em; color: #666; margin-bottom: 5px; }
        .scenario-themes { font-size: 0.9em; color: #555; }
        
        /* Color coding for probability ranges - PRESERVED */
        .prob-very-high { color: #dc3545; background: #f8d7da; border-left: 4px solid #dc3545; }
        .prob-high { color: #fd7e14; background: #ffeaa7; border-left: 4px solid #fd7e14; }
        .prob-medium { color: #28a745; background: #d4edda; border-left: 4px solid #28a745; }
        .prob-low { color: #6c757d; background: #e9ecef; border-left: 4px solid #6c757d; }

        /* ENHANCED - Step 5 Portfolio Optimization Styles for v2.0 */
        .portfolio-optimization-results { font-family: -apple-system, sans-serif; max-width: 1200px; margin: 0 auto; }
        .optimization-meta { color: #666; font-size: 0.9em; margin-bottom: 20px; }
        .summary-grid, .risk-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
        .allocation-grid { margin-top: 10px; }
        .allocation-row { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
        .security-info { flex: 1; }
        .security-info strong { display: block; }
        .security-info small { color: #666; font-size: 0.85em; }
        .allocation-bar { display: flex; align-items: center; gap: 10px; min-width: 150px; }
        .bar-fill { height: 20px; border-radius: 3px; }
        .percentage { font-weight: bold; min-width: 40px; text-align: right; }
        
        .optimization-container { max-width: 1200px; margin: 0 auto; }
        .allocation-summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
        .allocation-card { background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .allocation-card h4 { margin-bottom: 15px; color: #333; font-size: 1.1em; }
        .allocation-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .allocation-label { font-weight: 500; color: #555; }
        .allocation-percent { font-weight: bold; font-size: 1.1em; color: #667eea; }
        .allocation-bar-simple { height: 6px; background: #e9ecef; border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .allocation-fill-simple { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.5s ease; }
        
        .optimization-metrics { background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .metric-item { text-align: center; }
        .metric-value { font-size: 1.5em; font-weight: bold; color: #667eea; }
        .metric-label { font-size: 0.9em; color: #666; margin-top: 5px; }
        
        .optimization-notes { background: #e7f1ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 15px; margin: 20px 0; }
        .optimization-notes h4 { color: #0066cc; margin-bottom: 10px; }
        .optimization-notes ul { margin-left: 20px; }
        .optimization-notes li { margin-bottom: 5px; color: #004499; }

        /* Modal styles - PRESERVED */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
        .modal-content { background: white; margin: 5% auto; padding: 0; width: 90%; max-width: 600px; border-radius: 8px; }
        .modal-header { background: #667eea; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
        .modal-body { padding: 20px; }
        .modal-footer { padding: 20px; text-align: right; border-top: 1px solid #dee2e6; }
        
        /* File upload styles - PRESERVED */
        .file-upload {
            border: 2px dashed #ccc; border-radius: 8px; padding: 40px; text-align: center;
            background: #f8f9fa; cursor: pointer; transition: all 0.3s;
        }
        .file-upload:hover { border-color: #667eea; background: #e9ecef; }
        .file-upload.dragover { border-color: #667eea; background: #e7f1ff; }
        
        /* Philosophy styles - PRESERVED */
        .philosophy-content { max-width: 800px; margin: 0 auto; }
        .philosophy-intro { margin-bottom: 30px; }
        .acknowledgment { text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; }
        .acknowledgment label { display: flex; align-items: center; justify-content: center; gap: 10px; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>HCP Portfolio Tracker v6.5.4</h1>
            <div class="version-info">
                Regret Minimization Framework | PortfolioOptimizer v2.0 | IPS v3.10 Compliant
            </div>
        </div>
        
        <!-- Progress Bar -->
        <div class="progress-bar" id="progress-bar">
            <!-- Progress indicators will be generated by TrackerCore -->
        </div>
        
        <!-- Navigation -->
        <div class="navigation">
            <button class="nav-button" id="btn-prev">‚Üê Previous</button>
            <div id="step-title">Step 1: Investment Philosophy</div>
            <button class="nav-button" id="btn-next">Next ‚Üí</button>
        </div>
        
        <!-- Content Area -->
        <div class="content">
            <!-- Step 1: Philosophy - PRESERVED -->
            <div id="step-1" class="step-content active">
                <div class="philosophy-content">
                    <div class="philosophy-intro">
                        <h2>Welcome to the Humble Conviction Portfolio System</h2>
                        <p>This Investment Policy Statement outlines a systematic, probability-weighted approach to portfolio management based on macro regime analysis using sophisticated regret minimization techniques.</p>
                    </div>
                    <div class="acknowledgment">
                        <label>
                            <input type="checkbox" id="philosophy-checkbox">
                            <strong>I understand and acknowledge the investment philosophy</strong>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Step 2: Data Import - PRESERVED -->
            <div id="step-2" class="step-content">
                <div class="data-section">
                    <h2>Import Data Files</h2>
                    
                    <div style="margin-bottom: 30px;">
                        <h3>Monthly Update File</h3>
                        <div class="file-upload" onclick="document.getElementById('monthly-file').click()">
                            <input type="file" id="monthly-file" accept=".json" style="display: none;">
                            <div id="monthly-status">
                                üìÅ Click to select monthly update file or drag & drop<br>
                                <small>Format: hcp_data_monthly_YYYYMMDD_HHMMSS.json</small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sample Data Generator - PRESERVED -->
                    <div>
                        <h3>Or Generate Sample Data (FileHandler v1.5)</h3>
                        <p>Generate momentum-aware sample data for testing and demonstration:</p>
                        <div style="display: flex; gap: 15px; margin-top: 15px; flex-wrap: wrap;">
                            <button class="nav-button" onclick="generateSampleData('tech_boom')">Tech Boom</button>
                            <button class="nav-button" onclick="generateSampleData('usd_strength')">USD Strength</button>
                            <button class="nav-button" onclick="generateSampleData('pe_reversion')">P/E Reversion</button>
                            <button class="nav-button" onclick="generateSampleData('international')">International</button>
                            <button class="nav-button" onclick="generateSampleData('mixed_signals')">Mixed Signals</button>
                        </div>
                    </div>
                    
                    <!-- Data Editor Section - PRESERVED -->
                    <div id="data-editor-section" style="display: none; margin-top: 30px;">
                        <h3>Data Editor</h3>
                        <div id="data-table-container">
                            <!-- DataEditor table will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Step 3: Theme Analysis - PRESERVED -->
            <div id="step-3" class="step-content">
                <h2>Theme Analysis</h2>
                <div id="theme-container">
                    <p>Load data in Step 2 to begin theme analysis.</p>
                </div>
            </div>
            
            <!-- Step 4: Scenario Analysis - PRESERVED -->
            <div id="step-4" class="step-content">
                <div class="scenario-matrix">
                    <h2>16-Scenario Probability Matrix</h2>
                    <p>Based on theme probabilities from Step 3, here are all possible scenario combinations ranked by probability:</p>
                    
                    <div id="scenario-summary" style="margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                        <!-- Scenario summary stats will be displayed here -->
                    </div>
                    
                    <div id="scenario-container">
                        <p>Complete Step 3 to generate scenario analysis.</p>
                    </div>
                </div>
            </div>
            
            <!-- Step 5: Portfolio Optimization - ENHANCED with PortfolioOptimizer v2.0 -->
            <div id="step-5" class="step-content">
                <div class="optimization-container">
                    <h2>Portfolio Optimization - Regret Minimization Framework</h2>
                    <p>IPS v3.10 compliant regret minimization across 16 scenarios using dual optimization framework:</p>
                    
                    <!-- Optimization Results Container -->
                    <div id="portfolio-optimization-results">
                        <p>Complete Step 4 to begin regret minimization optimization.</p>
                    </div>
                </div>
            </div>
            
            <!-- Placeholder Steps 6-10 - PRESERVED -->
            <div id="step-6" class="step-content">
                <h2>Current Positions</h2>
                <p>Step 6 functionality will be implemented in a future release.</p>
                <div style="margin-top: 20px; padding: 20px; background: #fff3cd; border-radius: 8px;">
                    <strong>Coming Soon:</strong> Portfolio position entry and analysis.
                </div>
            </div>
            
            <div id="step-7" class="step-content">
                <h2>Rebalancing Trades</h2>
                <p>Step 7 functionality will be implemented in a future release.</p>
                <div style="margin-top: 20px; padding: 20px; background: #fff3cd; border-radius: 8px;">
                    <strong>Coming Soon:</strong> Trade generation and execution planning.
                </div>
            </div>
            
            <div id="step-8" class="step-content">
                <h2>History</h2>
                <p>Step 8 functionality will be implemented in a future release.</p>
                <div style="margin-top: 20px; padding: 20px; background: #fff3cd; border-radius: 8px;">
                    <strong>Coming Soon:</strong> Historical tracking and performance attribution.
                </div>
            </div>
            
            <div id="step-9" class="step-content">
                <h2>Report</h2>
                <p>Step 9 functionality will be implemented in a future release.</p>
                <div style="margin-top: 20px; padding: 20px; background: #fff3cd; border-radius: 8px;">
                    <strong>Coming Soon:</strong> Comprehensive analysis report generation.
                </div>
            </div>
            
            <div id="step-10" class="step-content">
                <h2>Export</h2>
                <p>Step 10 functionality will be implemented in a future release.</p>
                <div style="margin-top: 20px; padding: 20px; background: #fff3cd; border-radius: 8px;">
                    <strong>Coming Soon:</strong> Data export and system integration.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Modal - PRESERVED -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">Edit Indicator</h3>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div class="modal-footer">
                <button class="nav-button" onclick="DataEditor.closeEditModal()">Cancel</button>
                <button class="nav-button" onclick="saveIndicatorEdit()">Save Changes</button>
            </div>
        </div>
    </div>
    
    <script>
        // EMBEDDED TRACKER CORE v1.0 - Foundation Architecture - PRESERVED EXACTLY
        const TrackerCore = {
            version: '1.0',
            currentStep: 1,
            completedSteps: [],
            
            // Core state structure - NEVER modify this
            state: {
                philosophyAcknowledged: false,
                initializationData: null,
                monthlyData: null,
                dataQuality: {},
                manualOverrides: {},
                themeProbabilities: {},
                scenarioProbabilities: [],
                optimizedAllocation: {} // For Step 5
            },

            init: function() {
                this.loadState();
                this.navigateToStep(this.currentStep);
                this.setupEventListeners();
                console.log('TrackerCore v1.0 initialized with PortfolioOptimizer v2.0 integration');
            },

            // ROBUST navigation from core - PRESERVED
            navigateToStep: function(step) {
                if (step < 1 || step > 10) return false;
                
                if (!this.canNavigateToStep(step)) {
                    console.warn(`Cannot navigate to step ${step} - validation failed`);
                    return false;
                }

                this.currentStep = step;
                this.updateStepDisplay();
                this.updateStepIndicators();
                this.updateNavigation();
                this.saveState();
                
                console.log(`Navigated to step ${step}`);
                return true;
            },

            // ENHANCED validation logic from core - PRESERVED
            canNavigateToStep: function(step) {
                if (step === 1) return true;
                
                // Must complete previous steps in order
                for (let i = 1; i < step; i++) {
                    if (!this.isStepComplete(i)) {
                        return false;
                    }
                }
                return true;
            },

            // IMPROVED step completion checking from core - PRESERVED
            isStepComplete: function(step) {
                switch(step) {
                    case 1: 
                        return this.state.philosophyAcknowledged;
                    case 2: 
                        return this.state.monthlyData !== null;
                    case 3: 
                        return Object.keys(this.state.themeProbabilities).length > 0;
                    case 4:
                        return this.state.scenarioProbabilities.length === 16;
                    case 5:
                        return Object.keys(this.state.optimizedAllocation).length > 0;
                    default: 
                        return this.completedSteps.includes(step);
                }
            },

            // ROBUST step display from core - PRESERVED
            updateStepDisplay: function() {
                // Hide all steps
                document.querySelectorAll('.step-content').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Show current step
                const currentStepEl = document.getElementById(`step-${this.currentStep}`);
                if (currentStepEl) {
                    currentStepEl.classList.add('active');
                }
                
                // Update title
                const titles = [
                    'Investment Philosophy', 'Data Import & Edit', 'Theme Analysis',
                    'Scenario Analysis', 'Portfolio Optimization', 'Current Positions',
                    'Rebalancing Trades', 'History', 'Report', 'Export'
                ];
                
                const titleEl = document.getElementById('step-title');
                if (titleEl) {
                    titleEl.textContent = `Step ${this.currentStep}: ${titles[this.currentStep - 1]}`;
                }
            },

            // ENHANCED step indicators from core - PRESERVED
            updateStepIndicators: function() {
                const progressBar = document.getElementById('progress-bar');
                if (!progressBar) return;
                
                let html = '';
                for (let i = 1; i <= 10; i++) {
                    const isActive = i === this.currentStep;
                    const isCompleted = this.isStepComplete(i);
                    const isLocked = !this.canNavigateToStep(i);
                    
                    let classes = ['step-indicator'];
                    if (isActive) classes.push('active');
                    if (isCompleted) classes.push('completed');
                    if (isLocked) classes.push('locked');
                    
                    const statusLabels = ['Philosophy', 'Data', 'Themes', 'Scenarios', 'Optimize', 'Positions', 'Trades', 'History', 'Report', 'Export'];
                    
                    html += `
                        <div class="${classes.join(' ')}" onclick="TrackerCore.navigateToStep(${i})">
                            <div>Step ${i}</div>
                            <small>${statusLabels[i-1]}</small>
                        </div>
                    `;
                }
                
                progressBar.innerHTML = html;
            },

            updateNavigation: function() {
                const prevBtn = document.getElementById('btn-prev');
                const nextBtn = document.getElementById('btn-next');
                
                if (prevBtn) {
                    prevBtn.disabled = this.currentStep <= 1;
                    prevBtn.onclick = () => this.navigateToStep(this.currentStep - 1);
                }
                
                if (nextBtn) {
                    nextBtn.disabled = !this.canNavigateToStep(this.currentStep + 1);
                    nextBtn.onclick = () => this.navigateToStep(this.currentStep + 1);
                }
            },

            setupEventListeners: function() {
                // Philosophy checkbox - PRESERVED
                const checkbox = document.getElementById('philosophy-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', (e) => {
                        this.state.philosophyAcknowledged = e.target.checked;
                        if (e.target.checked && !this.completedSteps.includes(1)) {
                            this.completedSteps.push(1);
                        }
                        this.updateStepIndicators();
                        this.updateNavigation();
                        this.saveState();
                    });
                }

                // File upload - PRESERVED
                const monthlyFile = document.getElementById('monthly-file');
                if (monthlyFile) {
                    monthlyFile.addEventListener('change', handleMonthlyFile);
                }
                
                // Modal event listeners - PRESERVED
                window.addEventListener('click', (event) => {
                    const modal = document.getElementById('edit-modal');
                    if (event.target === modal) {
                        DataEditor.closeEditModal();
                    }
                });
                
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        DataEditor.closeEditModal();
                    }
                });
            },

            saveState: function() {
                const stateToSave = {
                    version: '6.5.4',
                    currentStep: this.currentStep,
                    completedSteps: this.completedSteps,
                    state: this.state,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem('hcp-tracker-v654-state', JSON.stringify(stateToSave));
            },

            loadState: function() {
                try {
                    const savedState = localStorage.getItem('hcp-tracker-v654-state') || 
                                    localStorage.getItem('hcp-tracker-v653-state') ||
                                    localStorage.getItem('hcp-tracker-v652-state') ||
                                    localStorage.getItem('hcp-tracker-v651-state') ||
                                    localStorage.getItem('hcp-tracker-v650-state');
                    
                    if (savedState) {
                        const parsed = JSON.parse(savedState);
                        this.currentStep = parsed.currentStep || 1;
                        this.completedSteps = parsed.completedSteps || [];
                        this.state = { ...this.state, ...parsed.state };
                        console.log('TrackerCore state restored from localStorage');
                    }
                } catch (error) {
                    console.error('Error loading state:', error);
                }
            }
        };

        // EMBEDDED FILE HANDLER v1.5 - Momentum-Aware Sample Data - PRESERVED EXACTLY
        const FileHandler = {
            version: '1.5',
            
            generateSampleData: function(type, scenario) {
                console.log(`FileHandler v1.5: Generating ${scenario} sample data`);
                
                const scenarios = {
                    'tech_boom': { usd: 0.25, ai: 0.80, pe: 0.35, intl: 0.30 },
                    'usd_strength': { usd: 0.75, ai: 0.20, pe: 0.25, intl: 0.15 },
                    'pe_reversion': { usd: 0.40, pe: 0.80, ai: 0.30, intl: 0.25 },
                    'international': { intl: 0.80, usd: 0.20, ai: 0.25, pe: 0.30 },
                    'mixed_signals': { usd: 0.50, ai: 0.50, pe: 0.50, intl: 0.50 }
                };
                
                const targetProbs = scenarios[scenario] || scenarios['mixed_signals'];
                
                return {
                    version: '1.5',
                    type: 'monthly',
                    timestamp: new Date().toISOString(),
                    scenario: scenario,
                    indicators: this.generateIndicatorData(targetProbs)
                };
            },
            
            generateIndicatorData: function(targetProbs) {
                // Generate realistic indicator data that will produce target theme probabilities
                return {
                    usd: {
                        dxy: this.generateMomentumData(97.5, targetProbs.usd > 0.5 ? -0.02 : 0.02),
                        gold: this.generateMomentumData(1950, targetProbs.usd > 0.5 ? 0.015 : -0.015),
                        yuanSwift: this.generateMomentumData(2.1, targetProbs.usd > 0.5 ? 0.03 : -0.03),
                        reserveShare: this.generateMomentumData(58.5, targetProbs.usd > 0.5 ? -0.01 : 0.01)
                    },
                    ai: {
                        productivity: this.generateMomentumData(115, targetProbs.ai > 0.5 ? 0.025 : -0.01),
                        qqqSpy: this.generateMomentumData(0.88, targetProbs.ai > 0.5 ? 0.02 : -0.02),
                        netMargins: this.generateMomentumData(12.5, targetProbs.ai > 0.5 ? 0.015 : -0.015)
                    },
                    pe: {
                        forwardPE: this.generateMomentumData(22, targetProbs.pe > 0.5 ? 0.03 : -0.02),
                        cape: this.generateMomentumData(32, targetProbs.pe > 0.5 ? 0.025 : -0.015),
                        riskPremium: this.generateMomentumData(2.5, targetProbs.pe > 0.5 ? -0.02 : 0.03)
                    },
                    intl: {
                        spVsWorld: this.generateMomentumData(-1.2, targetProbs.intl > 0.5 ? -0.03 : 0.02),
                        usAcwi: this.generateMomentumData(60, targetProbs.intl > 0.5 ? -0.01 : 0.01),
                        dxyLevel: this.generateMomentumData(97.5, targetProbs.intl > 0.5 ? -0.02 : 0.02),
                        ticFlows: this.generateMomentumData(125, targetProbs.intl > 0.5 ? 0.02 : -0.02)
                    }
                };
            },
            
            generateMomentumData: function(baseValue, momentum) {
                const history = [];
                let value = baseValue * (1 - momentum * 6); // Start 6 periods back
                
                // Generate 6-period history with momentum
                for (let i = 0; i < 6; i++) {
                    history.push(value);
                    value *= (1 + momentum + (Math.random() - 0.5) * 0.005); // Add small noise
                }
                
                return {
                    current: history[5],
                    history: history,
                    freshness: 'fresh',
                    source: 'FileHandler_v1.5_synthetic'
                };
            }
        };

        // EMBEDDED THEME CALCULATOR v2.9 - IPS v3.10 Compliant - PRESERVED EXACTLY
        const ThemeCalculator = {
            version: '2.9',
            
            calculateThemeAnalysis: function(data) {
                if (!data || !data.indicators) {
                    return { error: 'Invalid data structure' };
                }
                
                console.log('ThemeCalculator v2.9: Starting theme analysis...');
                
                const themes = {
                    usd: this.calculateThemeProbability(data.indicators.usd),
                    ai: this.calculateThemeProbability(data.indicators.ai),
                    pe: this.calculateThemeProbability(data.indicators.pe),
                    intl: this.calculateThemeProbability(data.indicators.intl)
                };
                
                // Generate 16 scenarios
                const scenarios = this.generateScenarios(themes);
                
                return {
                    version: '2.9',
                    methodology: 'IPS v3.10 Momentum Analysis',
                    timestamp: new Date().toISOString(),
                    themes: themes,
                    scenarios: scenarios
                };
            },
            
            calculateThemeProbability: function(themeData) {
                if (!themeData) return 0.15; // Default neutral
                
                let totalMomentum = 0;
                let indicatorCount = 0;
                
                Object.values(themeData).forEach(indicator => {
                    if (indicator.history && indicator.history.length >= 6) {
                        const current = indicator.current;
                        const sixBack = indicator.history[0];
                        const momentum = (current - sixBack) / sixBack;
                        totalMomentum += momentum;
                        indicatorCount++;
                    }
                });
                
                if (indicatorCount === 0) return 0.15;
                
                const avgMomentum = totalMomentum / indicatorCount;
                
                // Convert momentum to probability (sigmoid-like function)
                const probability = 0.15 + 0.7 / (1 + Math.exp(-avgMomentum * 10));
                
                return Math.max(0.05, Math.min(0.95, probability));
            },
            
            // EXISTING generateScenarios function - PRESERVED
            generateScenarios: function(themes) {
                const scenarios = [];
                
                // Generate all 16 binary combinations (0000-1111)
                for (let i = 0; i < 16; i++) {
                    const hasUSD = (i & 1) !== 0;   // Bit 0
                    const hasAI = (i & 2) !== 0;    // Bit 1  
                    const hasPE = (i & 4) !== 0;    // Bit 2
                    const hasINTL = (i & 8) !== 0;  // Bit 3
                    
                    // Calculate joint probability
                    const probability = 
                        (hasUSD ? themes.usd : (1 - themes.usd)) *
                        (hasAI ? themes.ai : (1 - themes.ai)) *
                        (hasPE ? themes.pe : (1 - themes.pe)) *
                        (hasINTL ? themes.intl : (1 - themes.intl));
                    
                    let name = [];
                    if (hasUSD) name.push('USD‚Üì');
                    if (hasAI) name.push('AI‚Üë');
                    if (hasPE) name.push('P/E‚Üì');
                    if (hasINTL) name.push('INTL‚Üë');
                    
                    scenarios.push({
                        id: i + 1,
                        binary: i.toString(2).padStart(4, '0'),
                        name: name.length > 0 ? name.join(' + ') : 'Base Case',
                        probability: probability,
                        rank: 0,
                        themes: { usd: hasUSD, ai: hasAI, pe: hasPE, intl: hasINTL }
                    });
                }
                
                // Sort by probability and assign ranks
                scenarios.sort((a, b) => b.probability - a.probability);
                scenarios.forEach((scenario, index) => {
                    scenario.rank = index + 1;
                });
                
                return scenarios;
            },

            displayThemeResults: function(analysis, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                const themeNames = {
                    usd: 'USD Dominance Decline',
                    ai: 'AI Productivity Boom', 
                    pe: 'P/E Mean Reversion',
                    intl: 'International Outperformance'
                };
                
                let html = `
                    <div class="theme-analysis-v651">
                        <div class="analysis-header">
                            <h3>Theme Analysis - ${analysis.methodology}</h3>
                            <div class="analysis-meta">Version ${analysis.version} | ${new Date(analysis.timestamp).toLocaleString()}</div>
                        </div>
                        <div class="theme-probabilities">
                            <h4>Theme Probabilities</h4>
                `;
                
                Object.entries(analysis.themes).forEach(([key, probability]) => {
                    const percentage = (probability * 100).toFixed(1);
                    const fillColor = probability > 0.6 ? '#28a745' : probability > 0.4 ? '#ffc107' : '#dc3545';
                    
                    html += `
                        <div class="theme-item">
                            <div class="theme-header">
                                <div class="theme-name">${themeNames[key]}</div>
                                <div class="theme-percentage">${percentage}%</div>
                            </div>
                            <div class="theme-bar">
                                <div class="theme-fill" style="width: ${percentage}%; background: ${fillColor};"></div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
                container.innerHTML = html;
                
                // Auto-trigger Step 4 scenario display if we have theme probabilities
                if (analysis.scenarios && analysis.scenarios.length === 16) {
                    this.displayScenarioMatrix(analysis.scenarios);
                }
            },
            
            // Display scenario matrix for Step 4 - PRESERVED
            displayScenarioMatrix: function(scenarios) {
                const container = document.getElementById('scenario-container');
                const summary = document.getElementById('scenario-summary');
                if (!container || !summary) return;
                
                // Update TrackerCore state
                TrackerCore.state.scenarioProbabilities = scenarios;
                
                // Display summary statistics
                const topScenario = scenarios[0];
                const totalProb = scenarios.reduce((sum, s) => sum + s.probability, 0);
                
                summary.innerHTML = `
                    <div style="display: flex; justify-content: space-around; text-align: center;">
                        <div>
                            <strong>Top Scenario</strong><br>
                            ${topScenario.name}<br>
                            <span style="color: #dc3545; font-size: 1.2em;">${(topScenario.probability * 100).toFixed(1)}%</span>
                        </div>
                        <div>
                            <strong>Scenarios > 10%</strong><br>
                            ${scenarios.filter(s => s.probability > 0.1).length} of 16<br>
                            <span style="color: #28a745; font-size: 1.2em;">${(scenarios.filter(s => s.probability > 0.1).length / 16 * 100).toFixed(0)}%</span>
                        </div>
                        <div>
                            <strong>Probability Check</strong><br>
                            Sum of all scenarios<br>
                            <span style="color: ${Math.abs(totalProb - 1) < 0.01 ? '#28a745' : '#dc3545'}; font-size: 1.2em;">${(totalProb * 100).toFixed(1)}%</span>
                        </div>
                    </div>
                `;
                
                // Generate scenario grid
                let html = '<div class="scenario-grid">';
                
                scenarios.forEach(scenario => {
                    const probability = scenario.probability * 100;
                    let probClass = 'prob-low';
                    if (probability > 15) probClass = 'prob-very-high';
                    else if (probability > 10) probClass = 'prob-high';
                    else if (probability > 5) probClass = 'prob-medium';
                    
                    html += `
                        <div class="scenario-card ${probClass}">
                            <div class="scenario-rank">Rank #${scenario.rank}</div>
                            <div class="scenario-name">${scenario.name}</div>
                            <div class="scenario-probability">${probability.toFixed(2)}%</div>
                            <div class="scenario-binary">Binary: ${scenario.binary}</div>
                            <div class="scenario-themes">
                                ${Object.entries(scenario.themes).map(([theme, active]) => 
                                    active ? theme.toUpperCase() : theme.toLowerCase()
                                ).join(' | ')}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                container.innerHTML = html;
                
                // Mark Step 4 as complete
                if (!TrackerCore.completedSteps.includes(4)) {
                    TrackerCore.completedSteps.push(4);
                }
                TrackerCore.updateStepIndicators();
                TrackerCore.updateNavigation();
                TrackerCore.saveState();
                
                // Auto-trigger Step 5 portfolio optimization with PortfolioOptimizer v2.0
                PortfolioOptimizer.optimizePortfolio(scenarios);
                
                console.log('Step 4: 16-scenario matrix displayed successfully');
            }
        };

        // NEW - EMBEDDED PORTFOLIO OPTIMIZER v2.0 - Regret Minimization Framework
        const PortfolioOptimizer = {
            version: '2.0',
            framework: 'IPS v3.10 Regret Minimization',
            lastUpdated: '2025-09-02T21:00:00.000Z',
            
            // IPS v3.10 Complete Security Universe (12 Assets)
            securities: {
                // Equity Exposures (5)
                VTI: { name: 'US Total Market', type: 'equity', category: 'us_equity' },
                VEA: { name: 'Developed International', type: 'equity', category: 'intl_equity' },
                VWO: { name: 'Emerging Markets', type: 'equity', category: 'intl_equity' },
                SMH: { name: 'Semiconductors', type: 'equity', category: 'tech_equity' },
                SRVR: { name: 'Infrastructure/Data Centers', type: 'equity', category: 'tech_equity' },
                
                // Income Exposures (2)
                PIMIX: { name: 'PIMCO Income Fund', type: 'income', category: 'income', holdOnly: true },
                PYLD: { name: 'PIMCO Yield Opportunities', type: 'income', category: 'income', primaryIncome: true },
                
                // Alternative Exposures (4)
                GLD: { name: 'Gold', type: 'alternative', category: 'commodities' },
                COM: { name: 'Commodities', type: 'alternative', category: 'commodities' },
                IGF: { name: 'Global Infrastructure', type: 'alternative', category: 'infrastructure' },
                DBMF: { name: 'Managed Futures', type: 'alternative', category: 'hedge' },
                
                // Cash (1)
                SWVXX: { name: 'Money Market', type: 'cash', category: 'cash' }
            },

            // IPS v3.10 Position Limits and Risk Constraints
            constraints: {
                maxSinglePosition: 0.35,        // 35% maximum single position
                maxSectorConcentration: 0.50,   // 50% maximum sector concentration
                minCashPosition: 0.01,          // 1% minimum cash
                maxAlternatives: 0.30,          // 30% maximum alternatives combined
                maxDBMF: 0.15,                  // 15% maximum DBMF (hedging limit)
                maxIncome: 0.30,                // 30% maximum combined income
                maxRegretTarget: {              // Variable based on correlation
                    high: 0.05,                 // 5% max regret if correlation > 0.7
                    medium: 0.06,               // 6% max regret if correlation 0.5-0.7
                    low: 0.08                   // 8% max regret if correlation < 0.5
                }
            },

            // Theme-Based Portfolio Tilts (IPS v3.10 Specifications)
            themeTilts: {
                usd: {  // USD Dominance Decline theme
                    name: 'USD Dominance Decline',
                    positive: { VEA: 0.05, VWO: 0.05, GLD: 0.03, COM: 0.02 },  // Increase these
                    negative: { VTI: -0.05, SWVXX: -0.10 }                      // Decrease these
                },
                ai: {   // AI Productivity Boom theme  
                    name: 'AI Productivity Boom',
                    positive: { SMH: 0.08, SRVR: 0.05, VTI: 0.02 },            // Increase tech
                    negative: { VEA: -0.03, PYLD: -0.02 }                       // Decrease traditional
                },
                pe: {   // P/E Mean Reversion theme
                    name: 'P/E Mean Reversion', 
                    positive: { PYLD: 0.05, GLD: 0.03, SWVXX: 0.05 },          // Increase defensive
                    negative: { SMH: -0.05, VTI: -0.03, VWO: -0.02 }           // Decrease growth
                },
                intl: { // International Outperformance theme
                    name: 'International Outperformance',
                    positive: { VEA: 0.08, VWO: 0.05, IGF: 0.02 },             // Increase international
                    negative: { VTI: -0.10, SMH: -0.03, SRVR: -0.02 }          // Decrease US equity
                }
            },

            /**
             * MAIN OPTIMIZATION ENTRY POINT
             * Execute complete 6-step portfolio optimization process
             */
            optimizePortfolio: function(scenarioProbabilities, options = {}) {
                console.log('=== HCP Portfolio Optimizer v2.0 - Starting Regret Minimization ===');
                console.log('Input scenarios:', scenarioProbabilities.length);
                
                const startTime = Date.now();
                const results = {
                    version: this.version,
                    framework: this.framework,
                    timestamp: new Date().toISOString(),
                    inputs: {
                        scenarios: scenarioProbabilities.length,
                        options: options
                    },
                    steps: {},
                    performance: {}
                };
                
                try {
                    // Step 1: Scenario Selection
                    const step1 = this.selectScenariosForOptimization(scenarioProbabilities);
                    results.steps.scenarioSelection = step1;
                    
                    // Step 2: Individual Scenario Optimization
                    const step2 = this.optimizeIndividualScenarios(step1.scenarios);
                    results.steps.individualOptimization = step2;
                    
                    // Step 3: Regret Matrix Calculation
                    const step3 = this.calculateRegretMatrix(step2, step1.scenarios);
                    results.steps.regretMatrix = step3;
                    
                    // Step 4: Dual Optimization
                    const step4 = this.runDualOptimization(step3.regretMatrix, step1.scenarios, step3.summary);
                    results.steps.dualOptimization = step4;
                    
                    // Step 5: Smart Hedging Protocol
                    const step5 = this.applySmartHedging(step4, step2, step1.scenarios);
                    results.steps.smartHedging = step5;
                    
                    // Step 6: Final Validation
                    const step6 = this.validateFinalAllocation(step5.allocation, step5);
                    results.steps.finalValidation = step6;
                    
                    // Final results
                    results.finalAllocation = step6.finalAllocation;
                    results.optimization = {
                        selectedScenarios: step1.scenarios.length,
                        cumulativeProbability: step1.cumulativeProbability,
                        optimalAlpha: step4.alpha,
                        maxRegret: step4.maxRegret,
                        weightedRegret: step4.weightedRegret,
                        hedgingApplied: step5.hedgingApplied,
                        validationPassed: step6.validationPassed
                    };
                    
                    results.performance.executionTimeMs = Date.now() - startTime;
                    results.performance.success = true;
                    
                    // Store results in TrackerCore state
                    TrackerCore.state.optimizedAllocation = {
                        allocation: results.finalAllocation,
                        optimization: results.optimization,
                        methodology: 'IPS v3.10 Regret Minimization',
                        timestamp: new Date().toISOString()
                    };
                    
                    // Display results
                    this.displayOptimizationResults(results, 'portfolio-optimization-results');
                    
                    // Mark Step 5 as complete
                    if (!TrackerCore.completedSteps.includes(5)) {
                        TrackerCore.completedSteps.push(5);
                    }
                    TrackerCore.updateStepIndicators();
                    TrackerCore.updateNavigation();
                    TrackerCore.saveState();
                    
                    console.log('=== Portfolio Optimization COMPLETED ===');
                    console.log(`Execution time: ${results.performance.executionTimeMs}ms`);
                    console.log('Final allocation:', this.formatAllocationSummary(results.finalAllocation));
                    
                    return results;
                    
                } catch (error) {
                    console.error('Portfolio optimization failed:', error);
                    results.performance.success = false;
                    results.performance.error = error.message;
                    results.performance.executionTimeMs = Date.now() - startTime;
                    return results;
                }
            },

            /**
             * STEP 1: SCENARIO SELECTION
             * Select scenarios for optimization based on IPS v3.10 criteria
             */
            selectScenariosForOptimization: function(scenarioProbabilities) {
                console.log('=== Step 1: Scenario Selection ===');
                
                // Sort scenarios by probability (highest first)
                const sortedScenarios = [...scenarioProbabilities].sort((a, b) => b.probability - a.probability);
                
                let selectedScenarios = [];
                let cumulativeProbability = 0;
                
                // Include until cumulative ‚â• 85%
                for (const scenario of sortedScenarios) {
                    selectedScenarios.push(scenario);
                    cumulativeProbability += scenario.probability;
                    
                    if (cumulativeProbability >= 0.85 && selectedScenarios.length >= 3) {
                        break;
                    }
                    
                    // Maximum 6 scenarios
                    if (selectedScenarios.length >= 6) {
                        break;
                    }
                }
                
                // Include any scenario ‚â• 10% probability regardless
                for (const scenario of sortedScenarios) {
                    if (scenario.probability >= 0.10 && !selectedScenarios.some(s => s.id === scenario.id)) {
                        selectedScenarios.push(scenario);
                    }
                }
                
                // Ensure minimum 3 scenarios
                if (selectedScenarios.length < 3) {
                    selectedScenarios = sortedScenarios.slice(0, 3);
                }
                
                const finalCumulative = selectedScenarios.reduce((sum, s) => sum + s.probability, 0);
                
                console.log(`Selected ${selectedScenarios.length} scenarios (${(finalCumulative*100).toFixed(1)}% cumulative):`, 
                           selectedScenarios.map(s => `S${s.id}:${(s.probability*100).toFixed(1)}%`));
                
                return {
                    scenarios: selectedScenarios,
                    cumulativeProbability: finalCumulative,
                    selectionCriteria: {
                        targetCumulative: 0.85,
                        actualCumulative: finalCumulative,
                        minScenarios: 3,
                        maxScenarios: 6,
                        selectedCount: selectedScenarios.length
                    }
                };
            },

            /**
             * STEP 2: INDIVIDUAL SCENARIO OPTIMIZATION
             * Create optimal allocation for each selected scenario with theme tilts
             */
            optimizeIndividualScenarios: function(selectedScenarios) {
                console.log('=== Step 2: Individual Scenario Optimization ===');
                
                const scenarioAllocations = {};
                
                for (const scenario of selectedScenarios) {
                    const allocation = this.createScenarioOptimalAllocation(scenario);
                    scenarioAllocations[scenario.id] = allocation;
                    
                    console.log(`S${scenario.id} optimal allocation:`, this.formatAllocationSummary(allocation));
                }
                
                return scenarioAllocations;
            },

            /**
             * Create optimal allocation for a specific scenario using theme tilts
             */
            createScenarioOptimalAllocation: function(scenario) {
                // Start with baseline allocation
                let allocation = this.getBaselineAllocation();
                
                // Apply theme tilts based on active themes in scenario
                const activeThemes = this.getActiveThemes(scenario);
                
                for (const themeKey of activeThemes) {
                    if (this.themeTilts[themeKey]) {
                        allocation = this.applyThemeTilt(allocation, this.themeTilts[themeKey]);
                    }
                }
                
                // Apply constraints and normalize
                allocation = this.applyConstraints(allocation);
                allocation = this.normalizeAllocation(allocation);
                
                return allocation;
            },

            /**
             * Get baseline allocation (neutral scenario)
             */
            getBaselineAllocation: function() {
                return {
                    VTI: 0.35,      // US equity core
                    VEA: 0.20,      // International developed
                    VWO: 0.10,      // Emerging markets
                    SMH: 0.08,      // Tech/semiconductors
                    SRVR: 0.05,     // Infrastructure
                    PYLD: 0.12,     // Primary income
                    PIMIX: 0.03,    // Legacy income (hold-only)
                    GLD: 0.02,      // Gold hedge
                    COM: 0.01,      // Commodities
                    IGF: 0.02,      // Infrastructure
                    DBMF: 0.01,     // Managed futures
                    SWVXX: 0.01     // Cash minimum
                };
            },

            /**
             * Determine active themes from scenario binary representation
             */
            getActiveThemes: function(scenario) {
                const activeThemes = [];
                
                // Parse scenario binary (format: ABCD where A=USD, B=AI, C=PE, D=INTL)
                const binary = scenario.binary || scenario.id.toString(2).padStart(4, '0');
                
                if (binary[0] === '1') activeThemes.push('usd');   // USD Decline active
                if (binary[1] === '1') activeThemes.push('ai');    // AI Boom active
                if (binary[2] === '1') activeThemes.push('pe');    // P/E Reversion active
                if (binary[3] === '1') activeThemes.push('intl');  // International active
                
                return activeThemes;
            },

            /**
             * Apply theme tilt to allocation
             */
            applyThemeTilt: function(allocation, tilt) {
                const newAllocation = {...allocation};
                
                // Apply positive tilts
                for (const [security, tiltAmount] of Object.entries(tilt.positive || {})) {
                    if (newAllocation[security] !== undefined) {
                        newAllocation[security] += tiltAmount;
                    }
                }
                
                // Apply negative tilts
                for (const [security, tiltAmount] of Object.entries(tilt.negative || {})) {
                    if (newAllocation[security] !== undefined) {
                        newAllocation[security] += tiltAmount; // tiltAmount is already negative
                    }
                }
                
                return newAllocation;
            },

            /**
             * STEP 3: REGRET MATRIX CALCULATION
             * Calculate regret for each allocation across all scenarios
             */
            calculateRegretMatrix: function(scenarioAllocations, selectedScenarios) {
                console.log('=== Step 3: Regret Matrix Calculation ===');
                
                const regretMatrix = {};
                const returnMatrix = {};
                
                // Calculate expected returns for each allocation in each scenario
                for (const [allocId, allocation] of Object.entries(scenarioAllocations)) {
                    returnMatrix[allocId] = {};
                    regretMatrix[allocId] = {};
                    
                    for (const scenario of selectedScenarios) {
                        const expectedReturn = this.calculateExpectedReturn(allocation, scenario);
                        returnMatrix[allocId][scenario.id] = expectedReturn;
                    }
                }
                
                // Calculate regret: Return(portfolio, scenario) - Return(optimal_for_scenario, scenario)
                for (const [allocId, allocation] of Object.entries(scenarioAllocations)) {
                    for (const scenario of selectedScenarios) {
                        const portfolioReturn = returnMatrix[allocId][scenario.id];
                        const optimalReturn = returnMatrix[scenario.id][scenario.id]; // Scenario's own optimal return
                        const regret = portfolioReturn - optimalReturn;
                        
                        regretMatrix[allocId][scenario.id] = regret;
                    }
                }
                
                // Calculate summary statistics
                const regretSummary = this.calculateRegretSummary(regretMatrix, selectedScenarios);
                
                console.log('Regret Matrix Summary:', regretSummary);
                
                return {
                    regretMatrix: regretMatrix,
                    returnMatrix: returnMatrix,
                    summary: regretSummary
                };
            },

            /**
             * Calculate expected return for allocation in specific scenario
             */
            calculateExpectedReturn: function(allocation, scenario) {
                // Simplified expected return calculation based on theme strength
                // In production, this would use detailed asset return models
                
                const activeThemes = this.getActiveThemes(scenario);
                let expectedReturn = 0.08; // Base 8% return assumption
                
                // Theme-based return adjustments
                const themeReturns = {
                    usd: { VEA: 0.03, VWO: 0.04, GLD: 0.15, COM: 0.08, VTI: -0.02 },
                    ai: { SMH: 0.18, SRVR: 0.12, VTI: 0.03, VEA: -0.01 },
                    pe: { PYLD: 0.06, GLD: 0.08, SWVXX: 0.02, SMH: -0.08, VTI: -0.05 },
                    intl: { VEA: 0.08, VWO: 0.12, IGF: 0.06, VTI: -0.03, SMH: -0.02 }
                };
                
                let themeAdjustment = 0;
                for (const theme of activeThemes) {
                    if (themeReturns[theme]) {
                        for (const [security, weight] of Object.entries(allocation)) {
                            const themeReturn = themeReturns[theme][security] || 0;
                            themeAdjustment += weight * themeReturn;
                        }
                    }
                }
                
                return expectedReturn + themeAdjustment;
            },

            /**
             * Calculate regret matrix summary statistics
             */
            calculateRegretSummary: function(regretMatrix, selectedScenarios) {
                const summary = {};
                
                for (const [allocId, regrets] of Object.entries(regretMatrix)) {
                    const regretValues = Object.values(regrets);
                    const maxRegret = Math.min(...regretValues); // Most negative = worst regret
                    
                    // Probability-weighted regret
                    let weightedRegret = 0;
                    for (const scenario of selectedScenarios) {
                        weightedRegret += scenario.probability * regrets[scenario.id];
                    }
                    
                    summary[allocId] = {
                        maxRegret: maxRegret,
                        weightedRegret: weightedRegret,
                        regretRange: Math.max(...regretValues) - Math.min(...regretValues),
                        scenarios: regrets
                    };
                }
                
                return summary;
            },

            /**
             * STEP 4: DUAL OPTIMIZATION
             * Find optimal Œ± parameter and blended allocation
             */
            runDualOptimization: function(regretMatrix, selectedScenarios, regretSummary) {
                console.log('=== Step 4: Dual Optimization ===');
                
                const alphaRange = [0.3, 0.4, 0.5, 0.6, 0.7]; // Test alpha values
                let bestResult = null;
                let bestScore = Infinity;
                
                for (const alpha of alphaRange) {
                    let bestAllocForAlpha = null;
                    let bestScoreForAlpha = Infinity;
                    
                    // Test each scenario allocation with this alpha
                    for (const [allocId, summary] of Object.entries(regretSummary)) {
                        const dualScore = alpha * Math.abs(summary.maxRegret) + (1 - alpha) * Math.abs(summary.weightedRegret);
                        
                        if (dualScore < bestScoreForAlpha) {
                            bestScoreForAlpha = dualScore;
                            bestAllocForAlpha = allocId;
                        }
                    }
                    
                    if (bestScoreForAlpha < bestScore) {
                        bestScore = bestScoreForAlpha;
                        bestResult = {
                            alpha: alpha,
                            allocation: bestAllocForAlpha,
                            score: bestScoreForAlpha,
                            maxRegret: regretSummary[bestAllocForAlpha].maxRegret,
                            weightedRegret: regretSummary[bestAllocForAlpha].weightedRegret
                        };
                    }
                }
                
                console.log(`Best dual optimization result: Œ±=${bestResult.alpha}, Score=${bestResult.score.toFixed(4)}`);
                console.log(`Max Regret: ${(bestResult.maxRegret*100).toFixed(2)}%, Weighted Regret: ${(bestResult.weightedRegret*100).toFixed(2)}%`);
                
                return bestResult;
            },

            /**
             * STEP 5: SMART HEDGING PROTOCOL
             * Apply smart hedging if regret exceeds tolerance
             */
            applySmartHedging: function(dualOptResult, scenarioAllocations, selectedScenarios) {
                console.log('=== Step 5: Smart Hedging Protocol ===');
                
                let finalAllocation = scenarioAllocations[dualOptResult.allocation];
                const maxRegretPercent = Math.abs(dualOptResult.maxRegret);
                
                // Assess portfolio correlation
                const correlation = this.assessPortfolioCorrelation(scenarioAllocations, selectedScenarios);
                let regretTolerance;
                
                if (correlation > 0.7) {
                    regretTolerance = this.constraints.maxRegretTarget.high; // 5%
                } else if (correlation > 0.5) {
                    regretTolerance = this.constraints.maxRegretTarget.medium; // 6%
                } else {
                    regretTolerance = this.constraints.maxRegretTarget.low; // 8%
                }
                
                console.log(`Portfolio correlation: ${correlation.toFixed(3)}, Regret tolerance: ${(regretTolerance*100).toFixed(1)}%`);
                console.log(`Current max regret: ${(maxRegretPercent*100).toFixed(2)}%`);
                
                if (maxRegretPercent > regretTolerance) {
                    console.log('Regret exceeds tolerance - applying smart hedging');
                    
                    const hedgingResult = this.determineHedgingStrategy(selectedScenarios, finalAllocation);
                    finalAllocation = this.applyHedging(finalAllocation, hedgingResult);
                    
                    return {
                        allocation: finalAllocation,
                        hedgingApplied: true,
                        hedgingReason: hedgingResult.reason,
                        hedgeAmount: hedgingResult.amount,
                        regretTolerance: regretTolerance,
                        originalMaxRegret: maxRegretPercent
                    };
                }
                
                return {
                    allocation: finalAllocation,
                    hedgingApplied: false,
                    regretTolerance: regretTolerance,
                    maxRegret: maxRegretPercent
                };
            },

            /**
             * Assess correlation between scenario allocations
             */
            assessPortfolioCorrelation: function(scenarioAllocations, selectedScenarios) {
                const allocations = selectedScenarios.map(s => scenarioAllocations[s.id]);
                const securities = Object.keys(this.securities);
                
                let totalCorrelation = 0;
                let pairCount = 0;
                
                for (let i = 0; i < allocations.length; i++) {
                    for (let j = i + 1; j < allocations.length; j++) {
                        const corr = this.calculateAllocationCorrelation(allocations[i], allocations[j], securities);
                        totalCorrelation += corr;
                        pairCount++;
                    }
                }
                
                return pairCount > 0 ? totalCorrelation / pairCount : 0;
            },

            /**
             * Calculate correlation between two allocations
             */
            calculateAllocationCorrelation: function(alloc1, alloc2, securities) {
                const values1 = securities.map(s => alloc1[s] || 0);
                const values2 = securities.map(s => alloc2[s] || 0);
                
                const mean1 = values1.reduce((sum, v) => sum + v, 0) / values1.length;
                const mean2 = values2.reduce((sum, v) => sum + v, 0) / values2.length;
                
                let numerator = 0;
                let sumSquares1 = 0;
                let sumSquares2 = 0;
                
                for (let i = 0; i < values1.length; i++) {
                    const diff1 = values1[i] - mean1;
                    const diff2 = values2[i] - mean2;
                    numerator += diff1 * diff2;
                    sumSquares1 += diff1 * diff1;
                    sumSquares2 += diff2 * diff2;
                }
                
                const denominator = Math.sqrt(sumSquares1 * sumSquares2);
                return denominator > 0 ? numerator / denominator : 0;
            },

            /**
             * Determine appropriate hedging strategy
             */
            determineHedgingStrategy: function(selectedScenarios, allocation) {
                // Analyze scenario divergence to determine hedge type
                const geographicDivergence = this.assessGeographicDivergence(selectedScenarios);
                const volatilityDivergence = this.assessVolatilityDivergence(selectedScenarios);
                
                if (volatilityDivergence > 0.6) {
                    return { type: 'volatility', hedge: 'DBMF', amount: 0.05, reason: 'High volatility divergence' };
                } else if (geographicDivergence > 0.5) {
                    return { type: 'geographic', hedge: 'VEA', amount: 0.03, reason: 'Geographic divergence' };
                } else {
                    return { type: 'cash', hedge: 'SWVXX', amount: 0.02, reason: 'Irreconcilable scenarios' };
                }
            },

            /**
             * Assess geographic divergence between scenarios
             */
            assessGeographicDivergence: function(scenarios) {
                // Simple heuristic based on international theme prevalence
                const intlActive = scenarios.filter(s => this.getActiveThemes(s).includes('intl')).length;
                return intlActive / scenarios.length;
            },

            /**
             * Assess volatility divergence between scenarios
             */
            assessVolatilityDivergence: function(scenarios) {
                // Heuristic based on theme combinations that create volatility
                let volatilityScenarios = 0;
                for (const scenario of scenarios) {
                    const themes = this.getActiveThemes(scenario);
                    if (themes.length >= 3 || themes.includes('ai') && themes.includes('pe')) {
                        volatilityScenarios++;
                    }
                }
                return volatilityScenarios / scenarios.length;
            },

            /**
             * Apply hedging to allocation
             */
            applyHedging: function(allocation, hedgingResult) {
                const newAllocation = {...allocation};
                const hedgeAmount = hedgingResult.amount;
                const hedgeSecurity = hedgingResult.hedge;
                
                // Add hedge position
                newAllocation[hedgeSecurity] = (newAllocation[hedgeSecurity] || 0) + hedgeAmount;
                
                // Reduce other positions proportionally
                const totalToReduce = hedgeAmount;
                const nonHedgeTotal = 1 - (newAllocation[hedgeSecurity] || 0);
                
                for (const [security, weight] of Object.entries(newAllocation)) {
                    if (security !== hedgeSecurity && weight > 0) {
                        const reduction = (weight / nonHedgeTotal) * totalToReduce;
                        newAllocation[security] = Math.max(0, weight - reduction);
                    }
                }
                
                return this.normalizeAllocation(newAllocation);
            },

            /**
             * STEP 6: FINAL VALIDATION
             * Apply constraints and validate final allocation
             */
            validateFinalAllocation: function(allocation, hedgingResult) {
                console.log('=== Step 6: Final Validation ===');
                
                let validatedAllocation = {...allocation};
                const validationResults = {
                    constraintViolations: [],
                    adjustmentsMade: [],
                    finalAllocation: null,
                    validationPassed: true
                };
                
                // Apply all constraints
                validatedAllocation = this.applyConstraints(validatedAllocation);
                
                // Check position limits
                for (const [security, weight] of Object.entries(validatedAllocation)) {
                    if (weight > this.constraints.maxSinglePosition) {
                        validationResults.constraintViolations.push(
                            `${security} exceeds max position limit: ${(weight*100).toFixed(1)}% > ${(this.constraints.maxSinglePosition*100).toFixed(1)}%`
                        );
                    }
                }
                
                // Ensure normalization
                validatedAllocation = this.normalizeAllocation(validatedAllocation);
                
                validationResults.finalAllocation = validatedAllocation;
                validationResults.validationPassed = validationResults.constraintViolations.length === 0;
                
                console.log(`Validation ${validationResults.validationPassed ? 'PASSED' : 'FAILED'}`);
                if (validationResults.constraintViolations.length > 0) {
                    console.log('Constraint violations:', validationResults.constraintViolations);
                }
                
                return validationResults;
            },

            /**
             * Apply position and risk constraints
             */
            applyConstraints: function(allocation) {
                let constrainedAllocation = {...allocation};
                
                // Apply maximum single position constraint
                for (const security of Object.keys(constrainedAllocation)) {
                    if (constrainedAllocation[security] > this.constraints.maxSinglePosition) {
                        constrainedAllocation[security] = this.constraints.maxSinglePosition;
                    }
                }
                
                // Ensure minimum cash position
                if (constrainedAllocation.SWVXX < this.constraints.minCashPosition) {
                    constrainedAllocation.SWVXX = this.constraints.minCashPosition;
                }
                
                // Apply PIMIX hold-only constraint
                if (this.securities.PIMIX.holdOnly && constrainedAllocation.PIMIX > 0.05) {
                    // Don't increase PIMIX beyond small existing position
                    constrainedAllocation.PIMIX = Math.min(constrainedAllocation.PIMIX, 0.05);
                }
                
                // Ensure non-negative allocations
                for (const security of Object.keys(constrainedAllocation)) {
                    constrainedAllocation[security] = Math.max(0, constrainedAllocation[security]);
                }
                
                return constrainedAllocation;
            },

            /**
             * Normalize allocation to sum to 100%
             */
            normalizeAllocation: function(allocation) {
                const total = Object.values(allocation).reduce((sum, weight) => sum + weight, 0);
                
                if (total === 0) {
                    return this.getBaselineAllocation(); // Fallback if everything is zero
                }
                
                const normalized = {};
                for (const [security, weight] of Object.entries(allocation)) {
                    normalized[security] = weight / total;
                }
                
                return normalized;
            },

            /**
             * Utility function to format allocation for display
             */
            formatAllocationSummary: function(allocation) {
                const summary = {};
                for (const [security, weight] of Object.entries(allocation)) {
                    if (weight > 0.005) { // Show only positions > 0.5%
                        summary[security] = `${(weight * 100).toFixed(1)}%`;
                    }
                }
                return summary;
            },

            /**
             * Display comprehensive optimization results
             */
            displayOptimizationResults: function(results, containerId) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error('Container not found:', containerId);
                    return;
                }
                
                const allocation = results.finalAllocation;
                const optimization = results.optimization;
                
                let html = `
                    <div class="portfolio-optimization-results">
                        <h3>Portfolio Optimization Results</h3>
                        <div class="optimization-meta">
                            <strong>Framework:</strong> ${results.framework} | 
                            <strong>Version:</strong> ${results.version} | 
                            <strong>Execution:</strong> ${results.performance.executionTimeMs}ms
                        </div>
                        
                        <div class="optimization-summary">
                            <h4>Optimization Summary</h4>
                            <div class="summary-grid">
                                <div>Selected Scenarios: <strong>${optimization.selectedScenarios}</strong></div>
                                <div>Cumulative Probability: <strong>${(optimization.cumulativeProbability*100).toFixed(1)}%</strong></div>
                                <div>Optimal Œ±: <strong>${optimization.optimalAlpha}</strong></div>
                                <div>Max Regret: <strong>${(optimization.maxRegret*100).toFixed(2)}%</strong></div>
                                <div>Weighted Regret: <strong>${(optimization.weightedRegret*100).toFixed(2)}%</strong></div>
                                <div>Hedging Applied: <strong>${optimization.hedgingApplied ? 'Yes' : 'No'}</strong></div>
                            </div>
                        </div>
                        
                        <div class="final-allocation">
                            <h4>Final Portfolio Allocation</h4>
                            <div class="allocation-grid">
                `;
                
                // Sort allocations by weight (descending)
                const sortedAllocations = Object.entries(allocation)
                    .sort(([,a], [,b]) => b - a)
                    .filter(([,weight]) => weight > 0.005); // Show only positions > 0.5%
                
                for (const [security, weight] of sortedAllocations) {
                    const securityInfo = this.securities[security];
                    const percentage = (weight * 100).toFixed(1);
                    const barWidth = Math.max(2, weight * 300); // Visual bar
                    
                    html += `
                        <div class="allocation-row">
                            <div class="security-info">
                                <strong>${security}</strong>
                                <small>${securityInfo?.name || 'Unknown'}</small>
                            </div>
                            <div class="allocation-bar">
                                <div class="bar-fill" style="width: ${barWidth}px; background-color: ${this.getSecurityColor(securityInfo?.type)}"></div>
                                <span class="percentage">${percentage}%</span>
                            </div>
                        </div>
                    `;
                }
                
                html += `
                            </div>
                        </div>
                        
                        <div class="risk-metrics">
                            <h4>Risk Analysis</h4>
                            <div class="risk-grid">
                                <div>Equity Exposure: <strong>${(this.calculateSectorWeight(allocation, 'equity')*100).toFixed(1)}%</strong></div>
                                <div>Income Exposure: <strong>${(this.calculateSectorWeight(allocation, 'income')*100).toFixed(1)}%</strong></div>
                                <div>Alternatives: <strong>${(this.calculateSectorWeight(allocation, 'alternative')*100).toFixed(1)}%</strong></div>
                                <div>Cash: <strong>${(this.calculateSectorWeight(allocation, 'cash')*100).toFixed(1)}%</strong></div>
                            </div>
                        </div>
                    </div>
                    
                    <style>
                        .portfolio-optimization-results { font-family: -apple-system, sans-serif; max-width: 800px; }
                        .optimization-meta { color: #666; font-size: 0.9em; margin-bottom: 20px; }
                        .summary-grid, .risk-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
                        .allocation-grid { margin-top: 10px; }
                        .allocation-row { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
                        .security-info { flex: 1; }
                        .security-info strong { display: block; }
                        .security-info small { color: #666; font-size: 0.85em; }
                        .allocation-bar { display: flex; align-items: center; gap: 10px; min-width: 150px; }
                        .bar-fill { height: 20px; border-radius: 3px; }
                        .percentage { font-weight: bold; min-width: 40px; text-align: right; }
                    </style>
                `;
                
                container.innerHTML = html;
            },

            /**
             * Calculate sector weight for risk analysis
             */
            calculateSectorWeight: function(allocation, sectorType) {
                let weight = 0;
                for (const [security, alloc] of Object.entries(allocation)) {
                    const securityInfo = this.securities[security];
                    if (securityInfo && securityInfo.type === sectorType) {
                        weight += alloc;
                    }
                }
                return weight;
            },

            /**
             * Get color for security type
             */
            getSecurityColor: function(type) {
                const colors = {
                    equity: '#007bff',      // Blue
                    income: '#28a745',      // Green  
                    alternative: '#ffc107', // Yellow
                    cash: '#6c757d'         // Gray
                };
                return colors[type] || '#dee2e6';
            }
        };

        // EMBEDDED DATA EDITOR v1.0 - RESTORED FROM v6.5.3 - PRESERVED EXACTLY
        const DataEditor = {
            version: '1.0',
            editingIndicator: null,
            
            displayDataTable: function(data, indicators, overrides) {
                if (!data || !data.indicators) return;
                
                const container = document.getElementById('data-table-container');
                if (!container) return;
                
                let html = '<table style="width: 100%; border-collapse: collapse; margin-top: 20px;">';
                html += '<thead><tr style="background: #f8f9fa;">';
                html += '<th style="padding: 10px; border: 1px solid #dee2e6; text-align: left;">Theme</th>';
                html += '<th style="padding: 10px; border: 1px solid #dee2e6; text-align: left;">Indicator</th>';
                html += '<th style="padding: 10px; border: 1px solid #dee2e6; text-align: left;">Current Value</th>';
                html += '<th style="padding: 10px; border: 1px solid #dee2e6; text-align: left;">Freshness</th>';
                html += '<th style="padding: 10px; border: 1px solid #dee2e6; text-align: left;">Source</th>';
                html += '<th style="padding: 10px; border: 1px solid #dee2e6; text-align: left;">Action</th>';
                html += '</tr></thead><tbody>';
                
                const themeNames = {
                    usd: 'USD Theme',
                    ai: 'AI Theme', 
                    pe: 'P/E Theme',
                    intl: 'International Theme'
                };
                
                Object.entries(data.indicators).forEach(([theme, themeData]) => {
                    Object.entries(themeData).forEach(([key, indicator]) => {
                        const dataKey = `${theme}_${key}`;
                        const isManual = overrides[dataKey];
                        const rowStyle = isManual ? 'background: #fff3cd; border: 1px solid #ffeaa7;' : 'border: 1px solid #dee2e6;';
                        
                        html += `<tr>`;
                        html += `<td style="padding: 10px; ${rowStyle}">${themeNames[theme] || theme}</td>`;
                        html += `<td style="padding: 10px; ${rowStyle}">${indicator.name || key}</td>`;
                        html += `<td style="padding: 10px; ${rowStyle}">${indicator.current ? indicator.current.toFixed(2) : 'N/A'}</td>`;
                        html += `<td style="padding: 10px; ${rowStyle}"><span style="color: #28a745;">‚úÖ Fresh</span></td>`;
                        html += `<td style="padding: 10px; ${rowStyle}">${isManual ? 'Manual' : indicator.source || 'Generated'}</td>`;
                        html += `<td style="padding: 10px; ${rowStyle}"><button onclick="DataEditor.openEditModal('${dataKey}', '${indicator.name || key}', ${indicator.current})" style="background: #667eea; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Edit</button></td>`;
                        html += '</tr>';
                    });
                });
                
                html += '</tbody></table>';
                container.innerHTML = html;
                
                console.log('DataEditor v1.0: Data table displayed with edit functionality');
            },
            
            openEditModal: function(dataKey, displayName, currentValue) {
                this.editingIndicator = dataKey;
                const modal = document.getElementById('edit-modal');
                const title = document.getElementById('modal-title');
                const body = document.getElementById('modal-body');
                
                title.textContent = `Edit: ${displayName}`;
                body.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Current Value:</label>
                        <input type="number" id="indicator-value" step="0.01" value="${currentValue || ''}" 
                               placeholder="Enter new value" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Reason for Manual Override:</label>
                        <select id="edit-reason" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;">
                            <option value="">Select reason...</option>
                            <option value="data_error">Data Collection Error</option>
                            <option value="timing_issue">Timing Issue</option>
                            <option value="market_event">Unusual Market Event</option>
                            <option value="manual_adjustment">Manual Adjustment</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Notes (Optional):</label>
                        <textarea id="edit-notes" rows="3" placeholder="Additional context..." 
                                  style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; resize: vertical;"></textarea>
                    </div>
                `;
                
                modal.style.display = 'block';
                
                // Focus on input
                setTimeout(() => {
                    document.getElementById('indicator-value').focus();
                }, 100);
            },
            
            closeEditModal: function() {
                const modal = document.getElementById('edit-modal');
                if (modal) modal.style.display = 'none';
                this.editingIndicator = null;
            },
            
            saveIndicatorEdit: function() {
                if (!this.editingIndicator) return;
                
                const newValue = parseFloat(document.getElementById('indicator-value').value);
                const reason = document.getElementById('edit-reason').value;
                const notes = document.getElementById('edit-notes').value;
                
                if (isNaN(newValue)) {
                    alert('Please enter a valid number');
                    return;
                }
                
                if (!reason) {
                    alert('Please select a reason for the manual override');
                    return;
                }
                
                // Save to TrackerCore manual overrides
                TrackerCore.state.manualOverrides[this.editingIndicator] = {
                    value: newValue,
                    reason: reason,
                    notes: notes,
                    timestamp: new Date().toISOString(),
                    originalValue: this.getOriginalValue(this.editingIndicator)
                };
                
                // Update the data structure with manual override
                this.applyManualOverride(this.editingIndicator, newValue);
                
                // Refresh the data table display
                this.displayDataTable(TrackerCore.state.monthlyData, {}, TrackerCore.state.manualOverrides);
                
                // Recalculate themes with new data
                calculateThemes();
                
                // Save state and close modal
                TrackerCore.saveState();
                this.closeEditModal();
                
                console.log(`Manual override saved for ${this.editingIndicator}: ${newValue}`);
            },
            
            getOriginalValue: function(dataKey) {
                // Extract original value from data structure
                const parts = dataKey.split('_');
                if (parts.length >= 2) {
                    const theme = parts[0];
                    const indicator = parts.slice(1).join('_');
                    
                    if (TrackerCore.state.monthlyData && 
                        TrackerCore.state.monthlyData.indicators &&
                        TrackerCore.state.monthlyData.indicators[theme] &&
                        TrackerCore.state.monthlyData.indicators[theme][indicator]) {
                        return TrackerCore.state.monthlyData.indicators[theme][indicator].current;
                    }
                }
                return null;
            },
            
            applyManualOverride: function(dataKey, newValue) {
                // Update the data structure with manual override
                const parts = dataKey.split('_');
                if (parts.length >= 2) {
                    const theme = parts[0];
                    const indicator = parts.slice(1).join('_');
                    
                    if (TrackerCore.state.monthlyData && 
                        TrackerCore.state.monthlyData.indicators &&
                        TrackerCore.state.monthlyData.indicators[theme] &&
                        TrackerCore.state.monthlyData.indicators[theme][indicator]) {
                        TrackerCore.state.monthlyData.indicators[theme][indicator].current = newValue;
                        TrackerCore.state.monthlyData.indicators[theme][indicator].source = 'manual_override';
                    }
                }
            }
        };

        // APPLICATION FUNCTIONS - PRESERVED FROM v6.5.3
        function generateSampleData(scenario) {
            console.log(`Generating ${scenario} sample data...`);
            
            const sampleData = FileHandler.generateSampleData('monthly', scenario);
            
            document.getElementById('monthly-status').innerHTML = 
                `<span class="status-good">‚úÖ ${scenario.replace('_', ' ')} sample data generated (v1.5)</span>`;
            
            // Update TrackerCore state
            TrackerCore.state.monthlyData = sampleData;
            
            if (!TrackerCore.completedSteps.includes(2)) {
                TrackerCore.completedSteps.push(2);
            }
            
            // Show data editor with generated data
            displayDataEditor();
            
            // Auto-calculate themes when data is loaded
            calculateThemes();
            
            TrackerCore.updateStepIndicators();
            TrackerCore.updateNavigation();
            TrackerCore.saveState();
            
            console.log('Sample data processed and state updated');
        }

        function displayDataEditor() {
            if (TrackerCore.state.monthlyData) {
                const container = document.getElementById('data-editor-section');
                if (container) {
                    container.style.display = 'block';
                    DataEditor.displayDataTable(TrackerCore.state.monthlyData, {}, TrackerCore.state.manualOverrides);
                }
            }
        }

        function handleMonthlyFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    document.getElementById('monthly-status').innerHTML = 
                        '<span class="status-good">‚úÖ Monthly data loaded</span>';
                    
                    TrackerCore.state.monthlyData = data;
                    if (!TrackerCore.completedSteps.includes(2)) {
                        TrackerCore.completedSteps.push(2);
                    }
                    
                    calculateThemes();
                    TrackerCore.updateStepIndicators();
                    TrackerCore.updateNavigation();
                    TrackerCore.saveState();
                    
                } catch (error) {
                    alert('Error parsing file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function calculateThemes() {
            if (!TrackerCore.state.monthlyData) return;
            
            console.log('Starting theme analysis with TrackerCore integration...');
            
            const analysis = ThemeCalculator.calculateThemeAnalysis(TrackerCore.state.monthlyData);
            
            if (analysis.error) {
                document.getElementById('theme-container').innerHTML = 
                    `<div class="status-error">Error: ${analysis.error}</div>`;
                return;
            }
            
            ThemeCalculator.displayThemeResults(analysis, 'theme-container');
            
            // Update TrackerCore state
            TrackerCore.state.themeProbabilities = analysis.themes;
            if (!TrackerCore.completedSteps.includes(3)) {
                TrackerCore.completedSteps.push(3);
            }
            
            TrackerCore.updateStepIndicators();
            TrackerCore.saveState();
        }

        function saveIndicatorEdit() {
            // Bridge to DataEditor functionality
            DataEditor.saveIndicatorEdit();
        }

        // INITIALIZE SYSTEM - TrackerCore as Foundation - PRESERVED
        window.addEventListener('load', function() {
            TrackerCore.init();
            
            // Set initial state if philosophy already acknowledged
            if (TrackerCore.state.philosophyAcknowledged) {
                document.getElementById('philosophy-checkbox').checked = true;
            }
            
            console.log('HCP Tracker v6.5.5 fully initialized with Step 4 fixes: binary order display, corrected color coding, and current scenario identification');
        });
    </script>
</body>
</html>