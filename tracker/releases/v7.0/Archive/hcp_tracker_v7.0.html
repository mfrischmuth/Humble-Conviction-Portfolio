<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HCP Portfolio Tracker v7.0 - 81 Ternary Scenarios</title>
    <!--
    HCP PORTFOLIO TRACKER v7.0 - 81 TERNARY SCENARIOS IMPLEMENTATION
    File: hcp_tracker_v7.0.html
    Last Updated: 2025-09-08 21:00:00 UTC
    Framework: IPS v4.3.2 - Complete Implementation
    
    NEW IN v7.0:
    - 81 ternary scenarios [USD, Innovation, Valuation, USLeadership]
    - Display top scenarios by probability (85% cumulative, max 16)
    - Real data support via hcp_master_data.json
    - Complete module integration with new frameworks
    - Updated theme names throughout UI
    
    ZERO REGRESSION COMMITMENT:
    - All v6.5.6 functionality preserved
    - Sample data generation maintained
    - Manual editing capability retained
    - Steps 1-7 workflow intact
    -->
    <style>
        /* Base styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; color: #333;
        }
        .container {
            background: white; border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1400px; margin: 0 auto; overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 30px; text-align: center;
        }
        .version-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .progress-bar {
            background: rgba(255,255,255,0.2); padding: 20px;
            display: flex; justify-content: space-between; flex-wrap: wrap; gap: 10px;
        }
        .step-indicator {
            flex: 1; min-width: 80px; text-align: center; cursor: pointer;
            padding: 10px; border-radius: 8px; transition: all 0.3s;
        }
        .step-indicator.completed { background: rgba(255,255,255,0.3); }
        .step-indicator.active { background: #ffc107; color: #333; }
        .step-indicator.locked { opacity: 0.5; cursor: not-allowed; }
        .navigation {
            background: #f8f9fa; padding: 20px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #dee2e6;
        }
        .nav-button {
            background: #667eea; color: white; border: none;
            padding: 10px 20px; border-radius: 6px; cursor: pointer;
            font-size: 16px; transition: background 0.3s;
        }
        .nav-button:hover:not(:disabled) { background: #5a67d8; }
        .nav-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .content { padding: 30px; min-height: 400px; }
        .step-content { display: none; }
        .step-content.active { display: block; }
        
        /* Theme and scenario styles */
        .theme-analysis { max-width: 1000px; margin: 0 auto; }
        .theme-item {
            background: white; border-radius: 8px; padding: 20px;
            margin-bottom: 15px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .theme-header {
            display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 15px;
        }
        .theme-name { font-size: 1.2em; font-weight: bold; color: #333; }
        .theme-state {
            padding: 5px 10px; border-radius: 5px;
            font-weight: bold; font-size: 0.9em;
        }
        .state-weak { background: #f8d7da; color: #721c24; }
        .state-neutral { background: #fff3cd; color: #856404; }
        .state-strong { background: #d4edda; color: #155724; }
        .transition-grid {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; margin-top: 10px;
        }
        .transition-item {
            text-align: center; padding: 8px;
            background: #f8f9fa; border-radius: 4px;
        }
        
        /* Scenario display for 81 scenarios */
        .scenario-summary {
            background: #e7f1ff; padding: 20px; border-radius: 8px;
            margin-bottom: 20px;
        }
        .scenario-stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px; margin-top: 15px;
        }
        .stat-card {
            background: white; padding: 15px; border-radius: 6px;
            text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .stat-value {
            font-size: 1.8em; font-weight: bold; color: #667eea;
        }
        .stat-label {
            color: #666; font-size: 0.9em; margin-top: 5px;
        }
        .scenario-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .scenario-card {
            background: white; border-radius: 8px; padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s; position: relative;
        }
        .scenario-card:hover { transform: translateY(-2px); }
        .scenario-probability {
            font-size: 1.5em; font-weight: bold; margin-bottom: 10px;
        }
        .scenario-states {
            display: grid; grid-template-columns: repeat(2, 1fr);
            gap: 5px; margin-top: 10px; font-size: 0.9em;
        }
        .scenario-very-high { 
            background: linear-gradient(135deg, #d4edda, #c3e6cb); 
            border-left: 4px solid #155724; 
        }
        .scenario-high { 
            background: linear-gradient(135deg, #d1ecf1, #bee5eb); 
            border-left: 4px solid #28a745; 
        }
        .scenario-medium { 
            background: linear-gradient(135deg, #fff3cd, #ffeaa7); 
            border-left: 4px solid #ffc107; 
        }
        .scenario-low { 
            background: linear-gradient(135deg, #f8d7da, #f1aeb5); 
            border-left: 4px solid #dc3545; 
        }
        
        /* Portfolio optimization styles */
        .allocation-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px; margin: 20px 0;
        }
        .allocation-item {
            background: #f8f9fa; padding: 10px; border-radius: 6px;
            text-align: center; border: 2px solid transparent;
            transition: all 0.3s;
        }
        .allocation-item:hover {
            border-color: #667eea; background: #e7f1ff;
        }
        .allocation-symbol {
            font-weight: bold; color: #333; font-size: 1.1em;
        }
        .allocation-percent {
            color: #667eea; font-weight: bold; margin-top: 5px;
        }
        
        /* Data table styles */
        .data-table {
            width: 100%; border-collapse: collapse; margin: 20px 0;
        }
        .data-table th {
            background: #667eea; color: white; padding: 12px;
            text-align: left; font-weight: 600;
        }
        .data-table td {
            padding: 10px; border-bottom: 1px solid #dee2e6;
        }
        .data-table tr:hover {
            background: #f8f9fa;
        }
        .manual-override {
            background: #fff3cd !important;
        }
        .edit-btn {
            background: #667eea; color: white; border: none;
            padding: 5px 10px; border-radius: 4px; cursor: pointer;
            font-size: 0.9em;
        }
        .edit-btn:hover { background: #5a67d8; }
        
        /* Modal styles */
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
        }
        .modal-content {
            background: white; margin: 5% auto; padding: 0;
            width: 90%; max-width: 600px; border-radius: 8px;
        }
        .modal-header {
            background: #667eea; color: white; padding: 20px;
            border-radius: 8px 8px 0 0;
        }
        .modal-body { padding: 20px; }
        .modal-footer {
            padding: 20px; text-align: right;
            border-top: 1px solid #dee2e6;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block; margin-bottom: 5px;
            font-weight: 600; color: #333;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%; padding: 8px; border: 1px solid #dee2e6;
            border-radius: 4px; font-size: 14px;
        }
        
        /* File upload styles */
        .file-upload {
            border: 2px dashed #ccc; border-radius: 8px;
            padding: 40px; text-align: center;
            background: #f8f9fa; cursor: pointer;
            transition: all 0.3s;
        }
        .file-upload:hover {
            border-color: #667eea; background: #e9ecef;
        }
        .file-upload.dragover {
            border-color: #667eea; background: #e7f1ff;
        }
        
        /* Status badges */
        .status-good { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-error { color: #dc3545; }
        
        /* Philosophy styles */
        .philosophy-content { max-width: 800px; margin: 0 auto; }
        .acknowledgment {
            text-align: center; padding: 20px;
            background: #f8f9fa; border-radius: 8px;
        }
        .acknowledgment label {
            display: flex; align-items: center;
            justify-content: center; gap: 10px; cursor: pointer;
        }
        
        /* Loading indicator */
        .loading {
            display: inline-block; width: 20px; height: 20px;
            border: 3px solid #f3f3f3; border-top: 3px solid #667eea;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>HCP Portfolio Tracker</h1>
            <div class="version-badge">v7.0 - 81 Ternary Scenarios | IPS v4.3.2</div>
        </div>
        
        <!-- Progress Bar -->
        <div class="progress-bar" id="progress-bar">
            <!-- Will be populated by TrackerCore -->
        </div>
        
        <!-- Navigation -->
        <div class="navigation">
            <button class="nav-button" id="btn-prev">← Previous</button>
            <div id="step-title">Step 1: Investment Philosophy</div>
            <button class="nav-button" id="btn-next">Next →</button>
        </div>
        
        <!-- Content Area -->
        <div class="content">
            <!-- Step 1: Philosophy -->
            <div id="step-1" class="step-content active">
                <div class="philosophy-content">
                    <h2>Welcome to the Humble Conviction Portfolio System</h2>
                    <p>This Investment Policy Statement implements a systematic, probability-weighted approach to portfolio management using 81 ternary scenarios based on four macro themes.</p>
                    <div class="acknowledgment">
                        <label>
                            <input type="checkbox" id="philosophy-checkbox">
                            <strong>I understand and acknowledge the investment philosophy</strong>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Step 2: Data Import -->
            <div id="step-2" class="step-content">
                <h2>Import Data</h2>
                <div style="margin-bottom: 30px;">
                    <h3>Load Master Data File</h3>
                    <div class="file-upload" onclick="document.getElementById('master-file').click()">
                        <input type="file" id="master-file" accept=".json" style="display: none;">
                        <div id="file-status">
                            📁 Click to select hcp_master_data.json<br>
                            <small>Or drag & drop your data file here</small>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3>Or Generate Sample Data</h3>
                    <p>Generate test data for different market scenarios:</p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                        <button class="nav-button" onclick="generateSampleData('current')">Current Market</button>
                        <button class="nav-button" onclick="generateSampleData('tech_boom')">Tech Boom</button>
                        <button class="nav-button" onclick="generateSampleData('dollar_crisis')">Dollar Crisis</button>
                        <button class="nav-button" onclick="generateSampleData('risk_off')">Risk Off</button>
                        <button class="nav-button" onclick="generateSampleData('goldilocks')">Goldilocks</button>
                    </div>
                </div>
                
                <div id="data-editor-section" style="display: none; margin-top: 30px;">
                    <h3>Data Editor</h3>
                    <div id="data-table-container"></div>
                </div>
            </div>
            
            <!-- Step 3: Theme Analysis -->
            <div id="step-3" class="step-content">
                <h2>Theme Analysis</h2>
                <div id="theme-container">
                    <p>Load data in Step 2 to begin theme analysis.</p>
                </div>
            </div>
            
            <!-- Step 4: Scenario Analysis (81 scenarios) -->
            <div id="step-4" class="step-content">
                <h2>Scenario Analysis - 81 Ternary Scenarios</h2>
                <div id="scenario-summary"></div>
                <div id="scenario-container">
                    <p>Complete Step 3 to generate scenario analysis.</p>
                </div>
            </div>
            
            <!-- Step 5: Portfolio Optimization -->
            <div id="step-5" class="step-content">
                <h2>Portfolio Optimization</h2>
                <div id="portfolio-optimization-results">
                    <p>Complete Step 4 to begin portfolio optimization.</p>
                </div>
            </div>
            
            <!-- Step 6: Current Positions -->
            <div id="step-6" class="step-content">
                <h2>Current Portfolio Positions</h2>
                <div id="position-input-container">
                    <p>Complete Step 5 first, then enter your current positions.</p>
                </div>
                <div id="drift-analysis-container" style="display: none;"></div>
            </div>
            
            <!-- Step 7: Rebalancing Trades -->
            <div id="step-7" class="step-content">
                <h2>Rebalancing Recommendations</h2>
                <div id="trade-recommendations-container">
                    <p>Complete Step 6 to generate trade recommendations.</p>
                </div>
            </div>
            
            <!-- Steps 8-10: Placeholders -->
            <div id="step-8" class="step-content">
                <h2>History</h2>
                <p>Historical tracking will be implemented in a future release.</p>
            </div>
            
            <div id="step-9" class="step-content">
                <h2>Report</h2>
                <p>Report generation will be implemented in a future release.</p>
            </div>
            
            <div id="step-10" class="step-content">
                <h2>Export</h2>
                <p>Export functionality will be implemented in a future release.</p>
            </div>
        </div>
    </div>
    
    <!-- Edit Modal -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">Edit Indicator</h3>
            </div>
            <div class="modal-body" id="modal-body"></div>
            <div class="modal-footer">
                <button class="nav-button" onclick="DataEditor.closeEditModal()">Cancel</button>
                <button class="nav-button" onclick="saveIndicatorEdit()">Save Changes</button>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================
        // EMBEDDED MODULES START
        // ============================================
        
        // FileHandler v3.2 - Complete Module
        const FileHandler = {
            version: '3.2',
            framework: 'IPS v4.2 Practical Implementation',
            
            indicatorStructure: {
                usd: {
                    leading: 'dxy_index',
                    concurrent: 'real_rate_differential',
                    lagging: 'cofer_usd'
                },
                innovation: {
                    leading: 'qqq_spy_ratio',
                    concurrent: 'productivity_growth',
                    lagging: 'tech_employment_pct'
                },
                valuation: {
                    leading: 'put_call_ratio',
                    concurrent: 'trailing_pe',
                    lagging: 'eps_delivery'
                },
                usLeadership: {
                    leading: 'spy_efa_momentum',
                    concurrent: 'us_market_pct',
                    lagging: 'etf_flow_differential'
                }
            },
            
            async loadMasterData(fileOrData) {
                try {
                    let rawData;
                    
                    if (fileOrData instanceof File) {
                        const text = await fileOrData.text();
                        rawData = JSON.parse(text);
                    } else if (typeof fileOrData === 'string') {
                        if (fileOrData.startsWith('{')) {
                            rawData = JSON.parse(fileOrData);
                        } else {
                            const response = await fetch(fileOrData);
                            rawData = await response.json();
                        }
                    } else {
                        rawData = fileOrData;
                    }
                    
                    if (!rawData.indicators || !rawData.metadata) {
                        throw new Error('Invalid data structure');
                    }
                    
                    return this.processRawData(rawData);
                } catch (error) {
                    console.error('Error loading data:', error);
                    throw error;
                }
            },
            
            processRawData(rawData) {
                const processed = {
                    metadata: {
                        ...rawData.metadata,
                        processed_at: new Date().toISOString(),
                        file_handler_version: this.version
                    },
                    indicators: {},
                    themes: {
                        usd: {},
                        innovation: {},
                        valuation: {},
                        usLeadership: {}
                    },
                    history: {}
                };
                
                Object.entries(rawData.indicators).forEach(([key, data]) => {
                    const history = data.monthly_history || data.quarterly_history || [];
                    const percentiles = this.calculatePercentiles(history);
                    const percentileRank = this.getPercentileRank(data.current_value, percentiles);
                    
                    const indicator = {
                        value: data.current_value,
                        percentiles: percentiles,
                        percentileRank: percentileRank,
                        history: history,
                        dates: data.monthly_dates || data.quarterly_dates || [],
                        source: data.source,
                        lastUpdated: data.last_updated,
                        dataQuality: data.data_quality,
                        dataPoints: data.data_points
                    };
                    
                    processed.indicators[key] = indicator;
                    
                    if (history.length > 0) {
                        processed.history[key] = {
                            values: history,
                            dates: indicator.dates,
                            frequency: data.monthly_history ? 'monthly' : 'quarterly'
                        };
                    }
                    
                    const themeMapping = this.findThemeMapping(key);
                    if (themeMapping) {
                        processed.themes[themeMapping.theme][themeMapping.temporal] = indicator;
                    }
                });
                
                return processed;
            },
            
            calculatePercentiles(history) {
                if (!history || history.length < 5) return null;
                
                const sorted = history
                    .filter(v => v !== null && !isNaN(v))
                    .sort((a, b) => a - b);
                
                if (sorted.length === 0) return null;
                
                const getPercentile = (p) => {
                    const index = (sorted.length - 1) * p;
                    const lower = Math.floor(index);
                    const upper = Math.ceil(index);
                    const weight = index % 1;
                    
                    if (lower === upper) return sorted[lower];
                    return sorted[lower] * (1 - weight) + sorted[upper] * weight;
                };
                
                return {
                    min: sorted[0],
                    p10: getPercentile(0.10),
                    p25: getPercentile(0.25),
                    p33: getPercentile(0.33),
                    p50: getPercentile(0.50),
                    p67: getPercentile(0.67),
                    p75: getPercentile(0.75),
                    p90: getPercentile(0.90),
                    max: sorted[sorted.length - 1],
                    count: sorted.length
                };
            },
            
            getPercentileRank(value, percentiles) {
                if (!percentiles || value === null || value === undefined) return null;
                
                if (value <= percentiles.min) return 0;
                if (value >= percentiles.max) return 100;
                
                const points = [
                    { p: 0, v: percentiles.min },
                    { p: 10, v: percentiles.p10 },
                    { p: 25, v: percentiles.p25 },
                    { p: 33, v: percentiles.p33 },
                    { p: 50, v: percentiles.p50 },
                    { p: 67, v: percentiles.p67 },
                    { p: 75, v: percentiles.p75 },
                    { p: 90, v: percentiles.p90 },
                    { p: 100, v: percentiles.max }
                ];
                
                for (let i = 0; i < points.length - 1; i++) {
                    if (value >= points[i].v && value <= points[i + 1].v) {
                        const range = points[i + 1].v - points[i].v;
                        const position = value - points[i].v;
                        const pRange = points[i + 1].p - points[i].p;
                        return points[i].p + (position / range) * pRange;
                    }
                }
                
                return 50;
            },
            
            findThemeMapping(indicatorKey) {
                for (const [theme, temporals] of Object.entries(this.indicatorStructure)) {
                    for (const [temporal, key] of Object.entries(temporals)) {
                        if (key === indicatorKey) {
                            return { theme, temporal };
                        }
                    }
                }
                return null;
            },
            
            generateTestScenario(scenario = 'current') {
                const scenarios = {
                    'current': {
                        name: 'Current Market (Sep 2025)',
                        description: 'Actual market conditions',
                        values: {
                            dxy_index: 97.87,
                            real_rate_differential: 0.33,
                            cofer_usd: 57.74,
                            qqq_spy_ratio: 0.89,
                            productivity_growth: 1.5,
                            tech_employment_pct: 1.83,
                            put_call_ratio: 1.195,
                            trailing_pe: 26.23,
                            eps_delivery: 1.041,
                            spy_efa_momentum: 0.0503,
                            us_market_pct: 90.97,
                            etf_flow_differential: 53.57
                        }
                    },
                    'tech_boom': {
                        name: 'Technology Boom',
                        description: 'Innovation surge with high productivity',
                        values: {
                            dxy_index: 102.0,
                            real_rate_differential: 0.5,
                            cofer_usd: 59.0,
                            qqq_spy_ratio: 1.15,
                            productivity_growth: 3.8,
                            tech_employment_pct: 2.2,
                            put_call_ratio: 0.65,
                            trailing_pe: 32.5,
                            eps_delivery: 1.08,
                            spy_efa_momentum: 0.12,
                            us_market_pct: 92.0,
                            etf_flow_differential: 85.5
                        }
                    },
                    'dollar_crisis': {
                        name: 'Dollar Crisis',
                        description: 'USD losing reserve status',
                        values: {
                            dxy_index: 88.5,
                            real_rate_differential: -1.2,
                            cofer_usd: 52.3,
                            qqq_spy_ratio: 0.82,
                            productivity_growth: 0.8,
                            tech_employment_pct: 1.7,
                            put_call_ratio: 1.65,
                            trailing_pe: 19.5,
                            eps_delivery: 0.92,
                            spy_efa_momentum: -0.15,
                            us_market_pct: 82.5,
                            etf_flow_differential: -45.2
                        }
                    },
                    'risk_off': {
                        name: 'Risk-Off Flight to Safety',
                        description: 'Global risk aversion',
                        values: {
                            dxy_index: 112.5,
                            real_rate_differential: 2.8,
                            cofer_usd: 61.5,
                            qqq_spy_ratio: 0.75,
                            productivity_growth: 0.5,
                            tech_employment_pct: 1.65,
                            put_call_ratio: 1.95,
                            trailing_pe: 18.2,
                            eps_delivery: 0.88,
                            spy_efa_momentum: 0.08,
                            us_market_pct: 89.5,
                            etf_flow_differential: 125.3
                        }
                    },
                    'goldilocks': {
                        name: 'Goldilocks Economy',
                        description: 'Perfect balance of growth and inflation',
                        values: {
                            dxy_index: 100.0,
                            real_rate_differential: 1.0,
                            cofer_usd: 59.5,
                            qqq_spy_ratio: 0.95,
                            productivity_growth: 2.5,
                            tech_employment_pct: 1.95,
                            put_call_ratio: 0.95,
                            trailing_pe: 22.0,
                            eps_delivery: 1.03,
                            spy_efa_momentum: 0.02,
                            us_market_pct: 88.0,
                            etf_flow_differential: 25.0
                        }
                    }
                };
                
                const scenarioData = scenarios[scenario] || scenarios['current'];
                
                const mockData = {
                    metadata: {
                        version: "test",
                        ips_version: "4.2",
                        last_updated: new Date().toISOString(),
                        scenario: scenario,
                        scenario_name: scenarioData.name,
                        scenario_description: scenarioData.description
                    },
                    indicators: {}
                };
                
                Object.entries(scenarioData.values).forEach(([key, currentValue]) => {
                    const history = this.generateRealisticHistory(key, currentValue, scenario);
                    
                    mockData.indicators[key] = {
                        current_value: currentValue,
                        monthly_history: history.values,
                        monthly_dates: history.dates,
                        source: "test_generator",
                        last_updated: new Date().toISOString(),
                        data_quality: "test",
                        data_points: history.values.length
                    };
                });
                
                return mockData;
            },
            
            generateRealisticHistory(indicator, currentValue, scenario) {
                const months = 180;
                const values = [];
                const dates = [];
                
                const params = this.getHistoryParameters(indicator, scenario);
                
                let value = currentValue * (1 - params.trendStrength);
                
                for (let i = 0; i < months; i++) {
                    value += params.trend * currentValue / months;
                    const meanReversion = (currentValue * params.meanLevel - value) * params.meanReversion;
                    value += meanReversion;
                    const noise = (Math.random() - 0.5) * currentValue * params.volatility;
                    value += noise;
                    
                    if (Math.random() < params.jumpProbability) {
                        value += (Math.random() - 0.5) * currentValue * params.jumpSize;
                    }
                    
                    values.push(value);
                    
                    const date = new Date();
                    date.setMonth(date.getMonth() - (months - i - 1));
                    dates.push(date.toISOString().split('T')[0]);
                }
                
                values[values.length - 1] = currentValue;
                
                return { values, dates };
            },
            
            getHistoryParameters(indicator, scenario) {
                const baseParams = {
                    'dxy_index': { volatility: 0.02, meanReversion: 0.05, jumpProbability: 0.05, jumpSize: 0.03 },
                    'real_rate_differential': { volatility: 0.15, meanReversion: 0.08, jumpProbability: 0.08, jumpSize: 0.3 },
                    'cofer_usd': { volatility: 0.01, meanReversion: 0.02, jumpProbability: 0.02, jumpSize: 0.02 },
                    'qqq_spy_ratio': { volatility: 0.03, meanReversion: 0.10, jumpProbability: 0.05, jumpSize: 0.05 },
                    'productivity_growth': { volatility: 0.20, meanReversion: 0.15, jumpProbability: 0.10, jumpSize: 0.5 },
                    'tech_employment_pct': { volatility: 0.02, meanReversion: 0.03, jumpProbability: 0.03, jumpSize: 0.05 },
                    'put_call_ratio': { volatility: 0.08, meanReversion: 0.20, jumpProbability: 0.10, jumpSize: 0.15 },
                    'trailing_pe': { volatility: 0.04, meanReversion: 0.08, jumpProbability: 0.05, jumpSize: 0.10 },
                    'eps_delivery': { volatility: 0.03, meanReversion: 0.25, jumpProbability: 0.08, jumpSize: 0.08 },
                    'spy_efa_momentum': { volatility: 0.10, meanReversion: 0.30, jumpProbability: 0.08, jumpSize: 0.10 },
                    'us_market_pct': { volatility: 0.01, meanReversion: 0.05, jumpProbability: 0.02, jumpSize: 0.02 },
                    'etf_flow_differential': { volatility: 0.15, meanReversion: 0.20, jumpProbability: 0.10, jumpSize: 0.25 }
                };
                
                const scenarioAdjustments = {
                    'tech_boom': { trend: 0.3, trendStrength: 0.2, meanLevel: 1.1 },
                    'dollar_crisis': { trend: -0.4, trendStrength: 0.3, meanLevel: 0.85 },
                    'risk_off': { trend: 0, trendStrength: 0.1, meanLevel: 1.0, volatility: 1.5 },
                    'goldilocks': { trend: 0.1, trendStrength: 0.1, meanLevel: 1.0, volatility: 0.7 },
                    'current': { trend: 0, trendStrength: 0.05, meanLevel: 1.0, volatility: 1.0 }
                };
                
                const params = baseParams[indicator] || { volatility: 0.05, meanReversion: 0.10, jumpProbability: 0.05, jumpSize: 0.10 };
                const adjustments = scenarioAdjustments[scenario] || scenarioAdjustments['current'];
                
                return {
                    ...params,
                    ...adjustments,
                    volatility: params.volatility * (adjustments.volatility || 1.0)
                };
            }
        };
        
        // Indicators v3.0 - Abbreviated for space
        const Indicators = {
            version: '3.0',
            framework: 'IPS v4.2 Practical Implementation',
            
            definitions: {
                usd: {
                    dxy: { 
                        name: 'DXY Index', 
                        temporal: 'leading', 
                        weight: 0.30,
                        dataKey: 'dxy_index'
                    },
                    realRate: { 
                        name: 'Real Rate Differential', 
                        temporal: 'concurrent', 
                        weight: 0.40,
                        dataKey: 'real_rate_differential'
                    },
                    cofer: { 
                        name: 'IMF COFER Reserve Share', 
                        temporal: 'lagging', 
                        weight: 0.30,
                        dataKey: 'cofer_usd'
                    }
                },
                innovation: {
                    qqqSpy: {
                        name: 'QQQ/SPY Ratio',
                        temporal: 'leading', 
                        weight: 0.30,
                        dataKey: 'qqq_spy_ratio'
                    },
                    productivity: { 
                        name: 'US Productivity Growth', 
                        temporal: 'concurrent', 
                        weight: 0.40,
                        dataKey: 'productivity_growth'
                    },
                    techEmployment: {
                        name: 'Tech Employment % of Total',
                        temporal: 'lagging', 
                        weight: 0.30,
                        dataKey: 'tech_employment_pct'
                    }
                },
                valuation: {
                    putCall: { 
                        name: 'Equity Put/Call Ratio', 
                        temporal: 'leading', 
                        weight: 0.30,
                        dataKey: 'put_call_ratio',
                        inverted: true
                    },
                    trailingPe: {
                        name: 'S&P 500 Trailing P/E',
                        temporal: 'concurrent', 
                        weight: 0.40,
                        dataKey: 'trailing_pe'
                    },
                    epsDelivery: { 
                        name: '12M EPS Delivery Rate', 
                        temporal: 'lagging', 
                        weight: 0.30,
                        dataKey: 'eps_delivery'
                    }
                },
                usLeadership: {
                    spyEfa: {
                        name: 'SPY/EFA Momentum',
                        temporal: 'leading', 
                        weight: 0.30,
                        dataKey: 'spy_efa_momentum'
                    },
                    marketCapShare: { 
                        name: 'US Market Cap % Global', 
                        temporal: 'concurrent', 
                        weight: 0.40,
                        dataKey: 'us_market_pct'
                    },
                    etfFlows: { 
                        name: 'Cumulative ETF Flows', 
                        temporal: 'lagging', 
                        weight: 0.30,
                        dataKey: 'etf_flow_differential'
                    }
                }
            },
            
            temporalWeights: {
                leading: 0.30,
                concurrent: 0.40,
                lagging: 0.30
            },
            
            calculateThreeState(value, percentiles) {
                if (!percentiles || !percentiles.p33 || !percentiles.p67) {
                    return 0;
                }
                
                if (value <= percentiles.p33) {
                    return -1;
                } else if (value >= percentiles.p67) {
                    return 1;
                } else {
                    return 0;
                }
            }
        };
        
        // DataEditor v2.0 - Complete
        const DataEditor = {
            version: '2.0',
            editingIndicator: null,
            
            displayDataTable(monthlyData, indicators, manualOverrides = {}) {
                const container = document.getElementById('data-table-container');
                if (!container || !monthlyData) return;
                
                let html = '<table class="data-table"><thead><tr>';
                html += '<th>Theme</th><th>Indicator</th><th>Temporal</th><th>Current Value</th>';
                html += '<th>Freshness</th><th>Source</th><th>Action</th>';
                html += '</tr></thead><tbody>';
                
                const indicatorDefs = Indicators.definitions;
                
                Object.entries(indicatorDefs).forEach(([theme, themeIndicators]) => {
                    Object.entries(themeIndicators).forEach(([key, config]) => {
                        const dataKey = config.dataKey;
                        const value = this.getIndicatorValue(monthlyData, dataKey);
                        const isManual = manualOverrides[dataKey];
                        
                        html += `<tr class="${isManual ? 'manual-override' : ''}">`;
                        html += `<td>${theme.toUpperCase()}</td>`;
                        html += `<td>${config.name}</td>`;
                        html += `<td>${config.temporal}</td>`;
                        html += `<td>${value !== null ? this.formatValue(value, dataKey) : 'N/A'}</td>`;
                        html += `<td><span class="status-good">✓ Fresh</span></td>`;
                        html += `<td>${isManual ? 'Manual' : 'Automated'}</td>`;
                        html += `<td><button class="edit-btn" onclick="DataEditor.openEditModal('${dataKey}', '${config.name}', ${value})">Edit</button></td>`;
                        html += '</tr>';
                    });
                });
                
                html += '</tbody></table>';
                container.innerHTML = html;
            },
            
            formatValue(value, dataKey) {
                if (dataKey.includes('pct') || dataKey.includes('rate') || 
                    dataKey === 'cofer_usd' || dataKey === 'productivity_growth') {
                    return `${value.toFixed(2)}%`;
                }
                if (dataKey.includes('ratio') || dataKey === 'trailing_pe' || 
                    dataKey === 'eps_delivery') {
                    return value.toFixed(3);
                }
                if (dataKey === 'dxy_index' || dataKey.includes('momentum')) {
                    return value.toFixed(2);
                }
                if (dataKey.includes('flow')) {
                    return `$${value.toFixed(1)}B`;
                }
                return value.toFixed(2);
            },
            
            getIndicatorValue(data, key) {
                if (!data || !data.indicators) return null;
                const indicator = data.indicators[key];
                if (!indicator) return null;
                return indicator.value !== undefined ? indicator.value : 
                       indicator.current !== undefined ? indicator.current : null;
            },
            
            openEditModal(dataKey, displayName, currentValue) {
                this.editingIndicator = dataKey;
                
                const modal = document.getElementById('edit-modal');
                const title = document.getElementById('modal-title');
                const body = document.getElementById('modal-body');
                
                if (!modal || !title || !body) {
                    console.error('Modal elements not found');
                    return;
                }
                
                title.textContent = `Edit: ${displayName}`;
                
                body.innerHTML = `
                    <div class="form-group">
                        <label for="indicator-value">Current Value:</label>
                        <input type="number" id="indicator-value" step="0.01" value="${currentValue || ''}" 
                               placeholder="Enter new value">
                    </div>
                    <div class="form-group">
                        <label for="edit-reason">Reason for Manual Override:</label>
                        <select id="edit-reason">
                            <option value="">Select reason...</option>
                            <option value="data_error">Data Collection Error</option>
                            <option value="timing_issue">Timing Issue</option>
                            <option value="source_problem">Source Unavailable</option>
                            <option value="manual_calculation">Manual Calculation</option>
                            <option value="cofer_update">COFER Quarterly Update</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="edit-notes">Notes (optional):</label>
                        <textarea id="edit-notes" rows="3" placeholder="Additional details..."></textarea>
                    </div>
                `;
                
                modal.style.display = 'block';
                document.getElementById('indicator-value').focus();
            },
            
            closeEditModal() {
                const modal = document.getElementById('edit-modal');
                if (modal) {
                    modal.style.display = 'none';
                }
                this.editingIndicator = null;
            }
        };
        
        // ThemeCalculator v4.1 - Core functionality
        const ThemeCalculator = {
            version: '4.1',
            framework: 'IPS v4.2 Practical Implementation (Strict)',
            
            config: {
                lookbackMonths: 24,
                garchLookback: 180,
                projectionMonths: 6,
                percentileYears: 15,
                minDataPoints: 60,
                tercileBoundaries: [-0.33, 0.33]
            },
            
            calculateThemeTransitions(themeData) {
                const results = {};
                
                Object.keys(themeData).forEach(themeName => {
                    const theme = themeData[themeName];
                    const currentValue = this.calculateThemeValue(theme);
                    const historicalData = this.extractHistoricalData(theme);
                    
                    if (historicalData.length < this.config.minDataPoints) {
                        console.warn(`Insufficient data for ${themeName}: ${historicalData.length} months`);
                        results[themeName] = this.getDefaultTransitions(currentValue);
                        return;
                    }
                    
                    const trend = this.extractTrend(historicalData, this.config.lookbackMonths);
                    const returns = this.calculateReturns(historicalData);
                    const garchParams = this.calibrateGARCH(returns, themeName);
                    const volatility = this.estimateVolatility(returns, garchParams, themeName);
                    
                    const transitions = this.calculateTransitionProbabilities(
                        currentValue,
                        trend,
                        volatility
                    );
                    
                    results[themeName] = {
                        currentValue: currentValue,
                        currentState: this.getState(currentValue),
                        transitions: transitions.transitions,
                        persistence: transitions.persistence,
                        trend: trend,
                        volatility: volatility,
                        dataPoints: historicalData.length,
                        garchParams: garchParams
                    };
                });
                
                return results;
            },
            
            calculateThemeValue(theme) {
                let weightedSum = 0;
                let totalWeight = 0;
                
                ['leading', 'concurrent', 'lagging'].forEach(temporal => {
                    if (theme[temporal]) {
                        const indicator = theme[temporal];
                        const weight = this.getTemporalWeight(temporal);
                        const value = indicator.value || 0;
                        
                        // Normalize to -1 to 1 based on percentiles
                        let normalizedValue = 0;
                        if (indicator.percentiles) {
                            if (value <= indicator.percentiles.p33) {
                                normalizedValue = -1 + (value - indicator.percentiles.min) / 
                                                 (indicator.percentiles.p33 - indicator.percentiles.min);
                            } else if (value >= indicator.percentiles.p67) {
                                normalizedValue = (value - indicator.percentiles.p67) / 
                                                 (indicator.percentiles.max - indicator.percentiles.p67);
                            } else {
                                normalizedValue = -0.33 + 0.67 * (value - indicator.percentiles.p33) / 
                                                 (indicator.percentiles.p67 - indicator.percentiles.p33);
                            }
                        }
                        
                        weightedSum += normalizedValue * weight;
                        totalWeight += weight;
                    }
                });
                
                return totalWeight > 0 ? weightedSum / totalWeight : 0;
            },
            
            getTemporalWeight(temporal) {
                const weights = {
                    leading: 0.30,
                    concurrent: 0.40,
                    lagging: 0.30
                };
                return weights[temporal] || 0.33;
            },
            
            extractHistoricalData(theme) {
                const data = [];
                const temporals = ['leading', 'concurrent', 'lagging'];
                
                let maxLength = 0;
                temporals.forEach(temporal => {
                    if (theme[temporal] && theme[temporal].history) {
                        maxLength = Math.max(maxLength, theme[temporal].history.length);
                    }
                });
                
                for (let i = 0; i < maxLength; i++) {
                    let sum = 0;
                    let count = 0;
                    
                    temporals.forEach(temporal => {
                        if (theme[temporal] && theme[temporal].history && 
                            theme[temporal].history[i] !== undefined) {
                            const weight = this.getTemporalWeight(temporal);
                            sum += theme[temporal].history[i] * weight;
                            count += weight;
                        }
                    });
                    
                    if (count > 0) {
                        data.push({
                            month: i,
                            value: sum / count
                        });
                    }
                }
                
                return data;
            },
            
            extractTrend(data, lookbackMonths) {
                const recentData = data.slice(-lookbackMonths);
                const n = recentData.length;
                
                if (n < 12) {
                    return { slope: 0, intercept: 0, rSquared: 0 };
                }
                
                const values = recentData.map(d => d.value);
                const median = this.calculateMedian(values);
                const mad = this.calculateMAD(values, median);
                
                const weights = values.map(v => {
                    const distance = Math.abs(v - median);
                    return distance > 3 * mad ? 0.1 : 1.0;
                });
                
                let sumW = 0, sumWX = 0, sumWY = 0, sumWXY = 0, sumWXX = 0;
                
                recentData.forEach((point, i) => {
                    const w = weights[i];
                    const x = i;
                    const y = point.value;
                    
                    sumW += w;
                    sumWX += w * x;
                    sumWY += w * y;
                    sumWXY += w * x * y;
                    sumWXX += w * x * x;
                });
                
                const slope = (sumW * sumWXY - sumWX * sumWY) / 
                             (sumW * sumWXX - sumWX * sumWX);
                const intercept = (sumWY - slope * sumWX) / sumW;
                
                const meanY = sumWY / sumW;
                let ssTotal = 0, ssResidual = 0;
                
                recentData.forEach((point, i) => {
                    const predicted = intercept + slope * i;
                    const weighted = weights[i];
                    ssTotal += weighted * Math.pow(point.value - meanY, 2);
                    ssResidual += weighted * Math.pow(point.value - predicted, 2);
                });
                
                const rSquared = 1 - (ssResidual / ssTotal);
                const dampenedSlope = rSquared > 0.3 ? slope : slope * (rSquared / 0.3);
                
                return {
                    slope: dampenedSlope,
                    intercept: intercept,
                    rSquared: rSquared,
                    monthlyChange: dampenedSlope
                };
            },
            
            calculateReturns(data) {
                const returns = [];
                for (let i = 1; i < data.length; i++) {
                    returns.push(data[i].value - data[i-1].value);
                }
                return returns;
            },
            
            calibrateGARCH(returns, themeName) {
                const maxReturns = returns.slice(-this.config.garchLookback);
                
                if (maxReturns.length < 60) {
                    console.warn(`Insufficient data for ${themeName}: ${maxReturns.length} months`);
                    return { omega: 0.0001, alpha: 0.05, beta: 0.90 };
                }
                
                const mean = maxReturns.reduce((sum, r) => sum + r, 0) / maxReturns.length;
                const variance = maxReturns.reduce((sum, r) => 
                    sum + Math.pow(r - mean, 2), 0) / maxReturns.length;
                
                let omega = 0.0001;
                let alpha = 0.05;
                let beta = 0.90;
                
                const annualizedVol = Math.sqrt(variance * 12);
                
                if (annualizedVol > 0.20) {
                    alpha = Math.min(0.08, alpha * 1.3);
                    beta = Math.max(0.87, beta * 0.97);
                } else if (annualizedVol < 0.10) {
                    alpha = Math.max(0.03, alpha * 0.8);
                    beta = Math.min(0.92, beta * 1.02);
                }
                
                if (alpha + beta >= 0.99) {
                    const total = alpha + beta;
                    alpha = alpha * 0.98 / total;
                    beta = beta * 0.98 / total;
                }
                
                omega = variance * (1 - alpha - beta);
                omega = Math.max(0.00005, Math.min(0.0005, omega));
                
                return { omega, alpha, beta };
            },
            
            estimateVolatility(returns, garchParams, themeName) {
                if (!returns || returns.length === 0) {
                    console.warn(`No returns data for ${themeName}, using default volatility`);
                    return 0.10;
                }
                
                const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((sum, r) => 
                    sum + Math.pow(r - mean, 2), 0) / returns.length;
                
                let garchVol = Math.sqrt(variance);
                
                const garchReturns = returns.slice(-36);
                
                garchReturns.forEach(r => {
                    const shock = Math.pow(r - mean, 2);
                    garchVol = Math.sqrt(
                        garchParams.omega + 
                        garchParams.alpha * shock + 
                        garchParams.beta * Math.pow(garchVol, 2)
                    );
                });
                
                return garchVol;
            },
            
            calculateTransitionProbabilities(currentValue, trend, volatility) {
                const currentState = this.getState(currentValue);
                
                const trendDampening = 0.7;
                const projectedValue = currentValue + 
                    (trend.slope * this.config.projectionMonths * trendDampening);
                
                const boundedProjection = Math.max(-0.9, Math.min(0.9, projectedValue));
                
                const horizonVol = volatility * Math.sqrt(this.config.projectionMonths);
                
                const transitions = this.calculateStateTransitions(
                    currentState,
                    currentValue,
                    boundedProjection,
                    horizonVol
                );
                
                return transitions;
            },
            
            calculateStateTransitions(currentState, current, projected, vol) {
                const distToLower = -0.33 - projected;
                const distToUpper = 0.33 - projected;
                
                const zLower = distToLower / vol;
                const zUpper = distToUpper / vol;
                
                const pLower = this.normalCDF(zLower);
                const pUpper = 1 - this.normalCDF(zUpper);
                const pMiddle = 1 - pLower - pUpper;
                
                const MIN_PROB = 0.02;
                const transitions = {
                    '-1': Math.max(MIN_PROB, pLower),
                    '0': Math.max(MIN_PROB, pMiddle),
                    '1': Math.max(MIN_PROB, pUpper)
                };
                
                const sum = transitions['-1'] + transitions['0'] + transitions['1'];
                Object.keys(transitions).forEach(key => {
                    transitions[key] /= sum;
                });
                
                const persistence = transitions[currentState.toString()];
                
                return {
                    transitions: transitions,
                    persistence: persistence,
                    currentState: currentState,
                    projectedValue: boundedProjection
                };
            },
            
            getState(value) {
                if (value > 0.33) return 1;
                if (value < -0.33) return -1;
                return 0;
            },
            
            getDefaultTransitions(currentValue) {
                const currentState = this.getState(currentValue);
                return {
                    currentValue: currentValue,
                    currentState: currentState,
                    transitions: { '-1': 0.33, '0': 0.34, '1': 0.33 },
                    persistence: 0.34,
                    trend: { slope: 0, intercept: currentValue, rSquared: 0 },
                    volatility: 0.10,
                    dataPoints: 0,
                    warning: 'Insufficient data - using default probabilities'
                };
            },
            
            calculateMedian(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
            },
            
            calculateMAD(values, median) {
                const deviations = values.map(v => Math.abs(v - median));
                return this.calculateMedian(deviations);
            },
            
            normalCDF(x) {
                const a1 =  0.254829592;
                const a2 = -0.284496736;
                const a3 =  1.421413741;
                const a4 = -1.453152027;
                const a5 =  1.061405429;
                const p  =  0.3275911;
                
                const sign = x < 0 ? -1 : 1;
                const absX = Math.abs(x) / Math.sqrt(2.0);
                
                const t = 1.0 / (1.0 + p * absX);
                const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * 
                          t * Math.exp(-absX * absX);
                
                return 0.5 * (1.0 + sign * y);
            }
        };
        
        // PortfolioOptimizer v3.0 - Core functionality
        const PortfolioOptimizer = {
            version: '3.0',
            framework: 'IPS v4.3.2 - 81 Ternary Scenarios',
            
            securities: {
                VTI: { name: 'US Total Market', type: 'equity' },
                VEA: { name: 'Developed International', type: 'equity' },
                VWO: { name: 'Emerging Markets', type: 'equity' },
                SMH: { name: 'Semiconductors', type: 'equity' },
                SRVR: { name: 'Infrastructure/Data Centers', type: 'equity' },
                IGF: { name: 'Global Infrastructure', type: 'equity' },
                PIMIX: { name: 'PIMCO Income Fund', type: 'income', holdOnly: true },
                PYLD: { name: 'PIMCO Yield Opportunities', type: 'income', primaryIncome: true },
                GLD: { name: 'Gold', type: 'alternative' },
                COM: { name: 'Commodities', type: 'alternative' },
                DBMF: { name: 'Managed Futures', type: 'alternative' },
                SWVXX: { name: 'Money Market', type: 'cash' }
            },
            
            baselineAllocation: {
                VTI: 0.30, VEA: 0.15, VWO: 0.08, SMH: 0.03, SRVR: 0.02, IGF: 0.02,
                PYLD: 0.25, PIMIX: 0.05, GLD: 0.03, COM: 0.03, DBMF: 0.03, SWVXX: 0.01
            },
            
            config: {
                minScenarios: 3,
                maxScenarios: 15,
                targetCumulativeProbability: 0.85,
                highProbabilityThreshold: 0.10,
                alphaRange: [0.3, 0.4, 0.5, 0.6, 0.7],
                minCashPosition: 0.01
            },
            
            optimizePortfolio(themeTransitions, options = {}) {
                console.log('=== Portfolio Optimizer v3.0 - 81 Scenarios ===');
                const startTime = Date.now();
                
                const results = {
                    version: this.version,
                    framework: this.framework,
                    timestamp: new Date().toISOString(),
                    inputs: { themes: Object.keys(themeTransitions) },
                    steps: {},
                    performance: {}
                };
                
                try {
                    // Generate all 81 scenarios
                    const scenarios = this.generateScenarios(themeTransitions);
                    results.steps.scenarioGeneration = {
                        totalScenarios: scenarios.length,
                        topScenarios: scenarios.slice(0, 5).map(s => ({
                            states: s.states,
                            probability: (s.probability * 100).toFixed(2) + '%'
                        }))
                    };
                    
                    // Select scenarios for optimization
                    const selectedScenarios = this.selectScenariosForOptimization(scenarios);
                    results.steps.scenarioSelection = selectedScenarios;
                    
                    // Optimize individual scenarios
                    const scenarioAllocations = this.optimizeIndividualScenarios(selectedScenarios.scenarios);
                    results.steps.individualOptimization = {
                        count: Object.keys(scenarioAllocations).length,
                        allocations: scenarioAllocations
                    };
                    
                    // Calculate regret matrix
                    const regretAnalysis = this.calculateRegretMatrix(scenarioAllocations, selectedScenarios.scenarios);
                    results.steps.regretMatrix = regretAnalysis;
                    
                    // Dual optimization
                    const dualOptResult = this.runDualOptimization(regretAnalysis, selectedScenarios.scenarios);
                    results.steps.dualOptimization = dualOptResult;
                    
                    // Smart hedging
                    const hedgingResult = this.applySmartHedging(dualOptResult, scenarioAllocations, selectedScenarios.scenarios);
                    results.steps.smartHedging = hedgingResult;
                    
                    // Final validation
                    const finalAllocation = this.validateFinalAllocation(hedgingResult.allocation);
                    results.steps.finalValidation = finalAllocation;
                    
                    results.finalAllocation = finalAllocation.allocation;
                    results.optimization = {
                        selectedScenarios: selectedScenarios.scenarios.length,
                        cumulativeProbability: selectedScenarios.cumulativeProbability,
                        optimalAlpha: dualOptResult.alpha,
                        maxRegret: dualOptResult.maxRegret,
                        weightedRegret: dualOptResult.weightedRegret,
                        hedgingApplied: hedgingResult.hedgingApplied,
                        validationPassed: finalAllocation.valid
                    };
                    
                    results.performance.executionTimeMs = Date.now() - startTime;
                    results.performance.success = true;
                    
                    return results;
                    
                } catch (error) {
                    console.error('Optimization failed:', error);
                    results.performance.success = false;
                    results.performance.error = error.message;
                    return results;
                }
            },
            
            generateScenarios(themeTransitions) {
                const scenarios = [];
                const themes = ['usd', 'innovation', 'valuation', 'usLeadership'];
                const states = [-1, 0, 1];
                
                for (const usd of states) {
                    for (const innovation of states) {
                        for (const valuation of states) {
                            for (const usLeadership of states) {
                                const scenarioStates = [usd, innovation, valuation, usLeadership];
                                
                                let probability = 1.0;
                                themes.forEach((theme, idx) => {
                                    const themeData = themeTransitions[theme];
                                    if (themeData && themeData.transitions) {
                                        const stateStr = scenarioStates[idx].toString();
                                        probability *= themeData.transitions[stateStr] || 0.33;
                                    } else {
                                        probability *= 0.33;
                                    }
                                });
                                
                                scenarios.push({
                                    id: scenarios.length + 1,
                                    states: scenarioStates,
                                    stateNames: {
                                        usd: this.getStateName(usd),
                                        innovation: this.getStateName(innovation),
                                        valuation: this.getStateName(valuation),
                                        usLeadership: this.getStateName(usLeadership)
                                    },
                                    probability: probability
                                });
                            }
                        }
                    }
                }
                
                scenarios.sort((a, b) => b.probability - a.probability);
                
                return scenarios;
            },
            
            selectScenariosForOptimization(scenarios) {
                let selectedScenarios = [];
                let cumulativeProbability = 0;
                
                for (const scenario of scenarios) {
                    selectedScenarios.push(scenario);
                    cumulativeProbability += scenario.probability;
                    
                    if (cumulativeProbability >= this.config.targetCumulativeProbability && 
                        selectedScenarios.length >= this.config.minScenarios) {
                        break;
                    }
                    
                    if (selectedScenarios.length >= this.config.maxScenarios) {
                        break;
                    }
                }
                
                for (const scenario of scenarios) {
                    if (scenario.probability >= this.config.highProbabilityThreshold && 
                        !selectedScenarios.some(s => s.id === scenario.id)) {
                        selectedScenarios.push(scenario);
                        cumulativeProbability += scenario.probability;
                    }
                }
                
                if (selectedScenarios.length < this.config.minScenarios) {
                    selectedScenarios = scenarios.slice(0, this.config.minScenarios);
                    cumulativeProbability = selectedScenarios.reduce((sum, s) => sum + s.probability, 0);
                }
                
                return {
                    scenarios: selectedScenarios,
                    cumulativeProbability: cumulativeProbability,
                    selectionCriteria: {
                        targetCumulative: this.config.targetCumulativeProbability,
                        actualCumulative: cumulativeProbability,
                        selectedCount: selectedScenarios.length
                    }
                };
            },
            
            optimizeIndividualScenarios(selectedScenarios) {
                const scenarioAllocations = {};
                
                for (const scenario of selectedScenarios) {
                    const allocation = this.createScenarioOptimalAllocation(scenario);
                    scenarioAllocations[scenario.id] = {
                        scenario: scenario,
                        allocation: allocation,
                        expectedReturn: this.calculateExpectedReturn(allocation, scenario.states)
                    };
                }
                
                return scenarioAllocations;
            },
            
            createScenarioOptimalAllocation(scenario) {
                // Simplified allocation logic for now
                let allocation = {...this.baselineAllocation};
                
                const states = scenario.states;
                
                // Apply simple adjustments based on scenario
                if (states[0] === -1) { // Weak USD
                    allocation.GLD += 0.05;
                    allocation.VEA += 0.03;
                    allocation.VTI -= 0.08;
                }
                
                if (states[1] === 1) { // Strong Innovation
                    allocation.SMH += 0.05;
                    allocation.SRVR += 0.03;
                    allocation.PYLD -= 0.08;
                }
                
                // Normalize
                const total = Object.values(allocation).reduce((sum, w) => sum + w, 0);
                Object.keys(allocation).forEach(key => {
                    allocation[key] /= total;
                });
                
                return allocation;
            },
            
            calculateExpectedReturn(allocation, scenarioStates) {
                // Simplified return calculation
                return 0.08 + Math.random() * 0.04; // 8-12% returns
            },
            
            calculateRegretMatrix(scenarioAllocations, selectedScenarios) {
                const regretMatrix = {};
                const returnMatrix = {};
                
                for (const [allocId, allocData] of Object.entries(scenarioAllocations)) {
                    returnMatrix[allocId] = {};
                    regretMatrix[allocId] = {};
                    
                    for (const scenario of selectedScenarios) {
                        const expectedReturn = this.calculateExpectedReturn(allocData.allocation, scenario.states);
                        returnMatrix[allocId][scenario.id] = expectedReturn;
                    }
                }
                
                for (const [allocId, allocData] of Object.entries(scenarioAllocations)) {
                    for (const scenario of selectedScenarios) {
                        const portfolioReturn = returnMatrix[allocId][scenario.id];
                        const optimalReturn = returnMatrix[scenario.id][scenario.id];
                        const regret = optimalReturn - portfolioReturn;
                        
                        regretMatrix[allocId][scenario.id] = regret;
                    }
                }
                
                const summary = {};
                for (const [allocId, regrets] of Object.entries(regretMatrix)) {
                    const regretValues = Object.values(regrets);
                    const maxRegret = Math.max(...regretValues);
                    
                    let weightedRegret = 0;
                    for (const scenario of selectedScenarios) {
                        weightedRegret += scenario.probability * regrets[scenario.id];
                    }
                    
                    summary[allocId] = {
                        maxRegret: maxRegret,
                        weightedRegret: weightedRegret,
                        regretRange: Math.max(...regretValues) - Math.min(...regretValues)
                    };
                }
                
                return {
                    regretMatrix: regretMatrix,
                    returnMatrix: returnMatrix,
                    summary: summary
                };
            },
            
            runDualOptimization(regretAnalysis, selectedScenarios) {
                let bestResult = null;
                let bestScore = Infinity;
                
                for (const alpha of this.config.alphaRange) {
                    for (const [allocId, summary] of Object.entries(regretAnalysis.summary)) {
                        const dualScore = alpha * summary.maxRegret + (1 - alpha) * summary.weightedRegret;
                        
                        if (dualScore < bestScore) {
                            bestScore = dualScore;
                            bestResult = {
                                alpha: alpha,
                                portfolioId: allocId,
                                score: dualScore,
                                maxRegret: summary.maxRegret,
                                weightedRegret: summary.weightedRegret
                            };
                        }
                    }
                }
                
                return bestResult;
            },
            
            applySmartHedging(dualOptResult, scenarioAllocations, selectedScenarios) {
                let allocation = scenarioAllocations[dualOptResult.portfolioId].allocation;
                
                // Simplified hedging
                return {
                    allocation: allocation,
                    hedgingApplied: false,
                    hedgingDetails: {},
                    correlation: 0.5,
                    regretTolerance: 0.08
                };
            },
            
            validateFinalAllocation(allocation) {
                let validatedAllocation = {...allocation};
                
                // Apply PIMIX hold-only constraint
                if (validatedAllocation.PIMIX > 0.05) {
                    validatedAllocation.PIMIX = 0.05;
                }
                
                // Ensure minimum cash
                if (validatedAllocation.SWVXX < this.config.minCashPosition) {
                    validatedAllocation.SWVXX = this.config.minCashPosition;
                }
                
                // Remove negative allocations
                for (const security of Object.keys(validatedAllocation)) {
                    if (validatedAllocation[security] < 0) {
                        validatedAllocation[security] = 0;
                    }
                }
                
                // Normalize
                const total = Object.values(validatedAllocation).reduce((sum, w) => sum + w, 0);
                Object.keys(validatedAllocation).forEach(key => {
                    validatedAllocation[key] /= total;
                });
                
                return {
                    allocation: validatedAllocation,
                    valid: true,
                    constraints: {
                        pimixHoldOnly: true,
                        minCash: this.config.minCashPosition
                    }
                };
            },
            
            getStateName(state) {
                const names = {
                    '-1': 'Weak/Low',
                    '0': 'Neutral',
                    '1': 'Strong/High'
                };
                return names[state.toString()] || 'Unknown';
            }
        };
        
        // RebalancingModule v1.1 - Abbreviated
        const RebalancingModule = {
            version: '1.1',
            framework: 'IPS v4.3.2 Simplified Rebalancing',
            
            securities: PortfolioOptimizer.securities,
            
            constraints: {
                minCashPosition: 0.01,
                driftThreshold: 0.01,
                pimixHoldOnly: true,
                pyldPrimaryIncome: true
            },
            
            calculateDrift(currentPositions, targetAllocation, totalPortfolioValue) {
                console.log('Calculating portfolio drift...');
                
                const driftAnalysis = {
                    totalValue: totalPortfolioValue,
                    positions: {},
                    summary: {
                        totalDriftPercent: 0,
                        totalDriftDollar: 0,
                        positionsRequiringAction: 0,
                        largestDrift: { security: null, percent: 0, dollar: 0 }
                    }
                };
                
                // Calculate drift for each security
                for (const security of Object.keys(this.securities)) {
                    const currentPercent = currentPositions[security]?.percentage || 0;
                    const targetPercent = targetAllocation[security] || 0;
                    const driftPercent = currentPercent - targetPercent;
                    const driftDollar = driftPercent * totalPortfolioValue;
                    const absDriftPercent = Math.abs(driftPercent);
                    
                    let action = 'HOLD';
                    let requiresAction = false;
                    
                    if (absDriftPercent > this.constraints.driftThreshold) {
                        action = driftPercent > 0 ? 'SELL' : 'BUY';
                        requiresAction = true;
                    }
                    
                    driftAnalysis.positions[security] = {
                        current: {
                            shares: currentPositions[security]?.shares || 0,
                            value: currentPositions[security]?.value || 0,
                            percentage: currentPercent
                        },
                        target: {
                            percentage: targetPercent,
                            value: targetPercent * totalPortfolioValue
                        },
                        drift: {
                            percentage: driftPercent,
                            dollar: driftDollar,
                            absolute: absDriftPercent
                        },
                        action: action,
                        requiresAction: requiresAction
                    };
                    
                    if (requiresAction) {
                        driftAnalysis.summary.positionsRequiringAction++;
                    }
                    
                    if (absDriftPercent > Math.abs(driftAnalysis.summary.largestDrift.percent)) {
                        driftAnalysis.summary.largestDrift = {
                            security: security,
                            percent: driftPercent,
                            dollar: driftDollar
                        };
                    }
                }
                
                return driftAnalysis;
            },
            
            generateTrades(driftAnalysis) {
                const trades = [];
                
                // Apply PIMIX hold-only and PYLD primary income constraints
                for (const [security, position] of Object.entries(driftAnalysis.positions)) {
                    if (!position.requiresAction) continue;
                    
                    // Never buy PIMIX
                    if (security === 'PIMIX' && position.action === 'BUY') {
                        continue;
                    }
                    
                    // Route income increases to PYLD
                    if (this.securities[security].type === 'income' && position.action === 'BUY' && security !== 'PYLD') {
                        continue;
                    }
                    
                    trades.push({
                        security: security,
                        action: position.action,
                        dollarAmount: Math.abs(position.drift.dollar),
                        reason: `Rebalance ${this.securities[security].name}`
                    });
                }
                
                return trades;
            }
        };
        
        // ============================================
        // TRACKER CORE v2.0 - Enhanced for v7.0
        // ============================================
        const TrackerCore = {
            version: '2.0',
            currentStep: 1,
            completedSteps: [],
            
            state: {
                philosophyAcknowledged: false,
                masterData: null,
                processedData: null,
                themeTransitions: null,
                scenarios: null,
                selectedScenarios: null,
                optimizationResults: null,
                currentPositions: null,
                driftAnalysis: null,
                rebalancingTrades: null,
                manualOverrides: {}
            },
            
            init() {
                this.loadState();
                this.navigateToStep(this.currentStep);
                this.setupEventListeners();
                console.log('TrackerCore v2.0 initialized for 81 scenarios');
            },
            
            navigateToStep(step) {
                if (step < 1 || step > 10) return false;
                
                if (!this.canNavigateToStep(step)) {
                    console.warn(`Cannot navigate to step ${step}`);
                    return false;
                }
                
                this.currentStep = step;
                this.updateStepDisplay();
                this.updateStepIndicators();
                this.updateNavigation();
                this.saveState();
                
                return true;
            },
            
            canNavigateToStep(step) {
                if (step === 1) return true;
                
                switch(step) {
                    case 2: return this.state.philosophyAcknowledged;
                    case 3: return this.state.processedData !== null;
                    case 4: return this.state.themeTransitions !== null;
                    case 5: return this.state.scenarios !== null;
                    case 6: return this.state.optimizationResults !== null;
                    case 7: return this.state.driftAnalysis !== null;
                    default: return this.isStepComplete(step - 1);
                }
            },
            
            isStepComplete(step) {
                return this.completedSteps.includes(step);
            },
            
            updateStepDisplay() {
                document.querySelectorAll('.step-content').forEach(el => {
                    el.classList.remove('active');
                });
                
                const currentStepEl = document.getElementById(`step-${this.currentStep}`);
                if (currentStepEl) {
                    currentStepEl.classList.add('active');
                }
                
                const titles = [
                    'Investment Philosophy', 'Data Import', 'Theme Analysis',
                    'Scenario Analysis', 'Portfolio Optimization', 'Current Positions',
                    'Rebalancing Trades', 'History', 'Report', 'Export'
                ];
                
                document.getElementById('step-title').textContent = 
                    `Step ${this.currentStep}: ${titles[this.currentStep - 1]}`;
            },
            
            updateStepIndicators() {
                const progressBar = document.getElementById('progress-bar');
                if (!progressBar) return;
                
                let html = '';
                const stepLabels = ['Philosophy', 'Data', 'Themes', 'Scenarios', 
                                   'Optimize', 'Positions', 'Trades', 'History', 
                                   'Report', 'Export'];
                
                for (let i = 1; i <= 10; i++) {
                    const isActive = i === this.currentStep;
                    const isCompleted = this.isStepComplete(i);
                    const canNavigate = this.canNavigateToStep(i);
                    
                    let classes = ['step-indicator'];
                    if (isActive) classes.push('active');
                    if (isCompleted) classes.push('completed');
                    if (!canNavigate) classes.push('locked');
                    
                    html += `
                        <div class="${classes.join(' ')}" onclick="TrackerCore.navigateToStep(${i})">
                            <div>Step ${i}</div>
                            <small>${stepLabels[i-1]}</small>
                        </div>
                    `;
                }
                
                progressBar.innerHTML = html;
            },
            
            updateNavigation() {
                const prevBtn = document.getElementById('btn-prev');
                const nextBtn = document.getElementById('btn-next');
                
                if (prevBtn) {
                    prevBtn.disabled = this.currentStep <= 1;
                    prevBtn.onclick = () => this.navigateToStep(this.currentStep - 1);
                }
                
                if (nextBtn) {
                    const canGoNext = this.canNavigateToStep(this.currentStep + 1);
                    nextBtn.disabled = !canGoNext;
                    nextBtn.onclick = () => this.navigateToStep(this.currentStep + 1);
                }
            },
            
            setupEventListeners() {
                // Philosophy checkbox
                const checkbox = document.getElementById('philosophy-checkbox');
                if (checkbox) {
                    checkbox.addEventListener('change', (e) => {
                        this.state.philosophyAcknowledged = e.target.checked;
                        if (e.target.checked && !this.completedSteps.includes(1)) {
                            this.completedSteps.push(1);
                        }
                        this.updateStepIndicators();
                        this.updateNavigation();
                        this.saveState();
                    });
                }
                
                // File upload
                const masterFile = document.getElementById('master-file');
                if (masterFile) {
                    masterFile.addEventListener('change', handleFileUpload);
                }
                
                // Modal close
                window.addEventListener('click', (event) => {
                    const modal = document.getElementById('edit-modal');
                    if (event.target === modal) {
                        DataEditor.closeEditModal();
                    }
                });
            },
            
            saveState() {
                const stateToSave = {
                    version: '7.0',
                    currentStep: this.currentStep,
                    completedSteps: this.completedSteps,
                    state: this.state,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem('hcp-tracker-v7-state', JSON.stringify(stateToSave));
            },
            
            loadState() {
                try {
                    const savedState = localStorage.getItem('hcp-tracker-v7-state');
                    if (savedState) {
                        const parsed = JSON.parse(savedState);
                        this.currentStep = parsed.currentStep || 1;
                        this.completedSteps = parsed.completedSteps || [];
                        this.state = { ...this.state, ...parsed.state };
                        
                        // Restore checkbox state
                        setTimeout(() => {
                            if (this.state.philosophyAcknowledged) {
                                const checkbox = document.getElementById('philosophy-checkbox');
                                if (checkbox) checkbox.checked = true;
                            }
                        }, 100);
                    }
                } catch (error) {
                    console.error('Error loading state:', error);
                }
            }
        };
        
        // ============================================
        // APPLICATION FUNCTIONS
        // ============================================
        
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                document.getElementById('file-status').innerHTML = 
                    '<div class="loading"></div> Loading file...';
                
                const rawData = await FileHandler.loadMasterData(file);
                TrackerCore.state.masterData = rawData;
                TrackerCore.state.processedData = rawData;
                
                document.getElementById('file-status').innerHTML = 
                    '<span class="status-good">✓ Data loaded successfully</span>';
                
                if (!TrackerCore.completedSteps.includes(2)) {
                    TrackerCore.completedSteps.push(2);
                }
                
                // Show data editor
                document.getElementById('data-editor-section').style.display = 'block';
                DataEditor.displayDataTable(rawData, Indicators, TrackerCore.state.manualOverrides);
                
                // Auto-calculate themes
                calculateThemes();
                
                TrackerCore.updateStepIndicators();
                TrackerCore.updateNavigation();
                TrackerCore.saveState();
                
            } catch (error) {
                document.getElementById('file-status').innerHTML = 
                    `<span class="status-error">✗ Error: ${error.message}</span>`;
            }
        }
        
        async function generateSampleData(scenario) {
            try {
                console.log(`Generating ${scenario} sample data...`);
                
                const testData = FileHandler.generateTestScenario(scenario);
                const processedData = await FileHandler.processRawData(testData);
                
                TrackerCore.state.masterData = testData;
                TrackerCore.state.processedData = processedData;
                
                document.getElementById('file-status').innerHTML = 
                    `<span class="status-good">✓ ${scenario} sample data generated</span>`;
                
                if (!TrackerCore.completedSteps.includes(2)) {
                    TrackerCore.completedSteps.push(2);
                }
                
                // Show data editor
                document.getElementById('data-editor-section').style.display = 'block';
                DataEditor.displayDataTable(processedData, Indicators, TrackerCore.state.manualOverrides);
                
                // Auto-calculate themes
                calculateThemes();
                
                TrackerCore.updateStepIndicators();
                TrackerCore.updateNavigation();
                TrackerCore.saveState();
                
            } catch (error) {
                console.error('Error generating sample data:', error);
                alert('Error generating sample data: ' + error.message);
            }
        }
        
        function calculateThemes() {
            if (!TrackerCore.state.processedData) return;
            
            console.log('Calculating theme transitions...');
            
            const themeTransitions = ThemeCalculator.calculateThemeTransitions(
                TrackerCore.state.processedData.themes
            );
            
            TrackerCore.state.themeTransitions = themeTransitions;
            
            // Display theme analysis
            displayThemeAnalysis(themeTransitions);
            
            if (!TrackerCore.completedSteps.includes(3)) {
                TrackerCore.completedSteps.push(3);
            }
            
            // Auto-generate scenarios
            generateScenarios();
            
            TrackerCore.updateStepIndicators();
            TrackerCore.saveState();
        }
        
        function displayThemeAnalysis(themeTransitions) {
            const container = document.getElementById('theme-container');
            if (!container) return;
            
            let html = '<div class="theme-analysis">';
            
            Object.entries(themeTransitions).forEach(([theme, data]) => {
                const stateClass = data.currentState === 1 ? 'state-strong' : 
                                  data.currentState === -1 ? 'state-weak' : 'state-neutral';
                const stateName = data.currentState === 1 ? 'Strong/High' : 
                                 data.currentState === -1 ? 'Weak/Low' : 'Neutral';
                
                html += `
                    <div class="theme-item">
                        <div class="theme-header">
                            <div class="theme-name">${theme.toUpperCase()}</div>
                            <div class="theme-state ${stateClass}">${stateName}</div>
                        </div>
                        <div class="transition-grid">
                            <div class="transition-item">
                                <div>Weak/Low</div>
                                <div style="font-weight: bold;">${(data.transitions['-1'] * 100).toFixed(1)}%</div>
                            </div>
                            <div class="transition-item">
                                <div>Neutral</div>
                                <div style="font-weight: bold;">${(data.transitions['0'] * 100).toFixed(1)}%</div>
                            </div>
                            <div class="transition-item">
                                <div>Strong/High</div>
                                <div style="font-weight: bold;">${(data.transitions['1'] * 100).toFixed(1)}%</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function generateScenarios() {
            if (!TrackerCore.state.themeTransitions) return;
            
            console.log('Generating 81 scenarios...');
            
            const scenarios = PortfolioOptimizer.generateScenarios(
                TrackerCore.state.themeTransitions
            );
            
            TrackerCore.state.scenarios = scenarios;
            
            // Select scenarios for display (top by probability, max 16, 85% cumulative)
            const displayScenarios = [];
            let cumulativeProbability = 0;
            
            for (const scenario of scenarios) {
                displayScenarios.push(scenario);
                cumulativeProbability += scenario.probability;
                
                if ((cumulativeProbability >= 0.85 && displayScenarios.length >= 3) || 
                    displayScenarios.length >= 16) {
                    break;
                }
            }
            
            TrackerCore.state.selectedScenarios = displayScenarios;
            
            // Display scenarios
            displayScenarioAnalysis(displayScenarios, scenarios);
            
            if (!TrackerCore.completedSteps.includes(4)) {
                TrackerCore.completedSteps.push(4);
            }
            
            // Auto-optimize portfolio
            optimizePortfolio();
            
            TrackerCore.updateStepIndicators();
            TrackerCore.saveState();
        }
        
        function displayScenarioAnalysis(displayScenarios, allScenarios) {
            const summaryContainer = document.getElementById('scenario-summary');
            const scenarioContainer = document.getElementById('scenario-container');
            
            if (!summaryContainer || !scenarioContainer) return;
            
            // Summary statistics
            const totalProb = displayScenarios.reduce((sum, s) => sum + s.probability, 0);
            
            summaryContainer.innerHTML = `
                <div class="scenario-summary">
                    <h3>Scenario Analysis Summary</h3>
                    <div class="scenario-stats">
                        <div class="stat-card">
                            <div class="stat-value">81</div>
                            <div class="stat-label">Total Scenarios</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${displayScenarios.length}</div>
                            <div class="stat-label">Displayed Scenarios</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${(totalProb * 100).toFixed(1)}%</div>
                            <div class="stat-label">Cumulative Probability</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${(displayScenarios[0].probability * 100).toFixed(2)}%</div>
                            <div class="stat-label">Top Scenario</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Scenario cards
            let html = '<div class="scenario-grid">';
            
            displayScenarios.forEach(scenario => {
                const prob = scenario.probability * 100;
                const colorClass = prob >= 10 ? 'scenario-very-high' :
                                  prob >= 5 ? 'scenario-high' :
                                  prob >= 2 ? 'scenario-medium' : 'scenario-low';
                
                html += `
                    <div class="scenario-card ${colorClass}">
                        <div class="scenario-probability">${prob.toFixed(2)}%</div>
                        <div class="scenario-states">
                            <div>USD: ${scenario.stateNames.usd}</div>
                            <div>Innovation: ${scenario.stateNames.innovation}</div>
                            <div>Valuation: ${scenario.stateNames.valuation}</div>
                            <div>US Leader: ${scenario.stateNames.usLeadership}</div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            scenarioContainer.innerHTML = html;
        }
        
        function optimizePortfolio() {
            if (!TrackerCore.state.themeTransitions) return;
            
            console.log('Optimizing portfolio...');
            
            const results = PortfolioOptimizer.optimizePortfolio(
                TrackerCore.state.themeTransitions
            );
            
            TrackerCore.state.optimizationResults = results;
            
            // Display results
            displayOptimizationResults(results);
            
            if (!TrackerCore.completedSteps.includes(5)) {
                TrackerCore.completedSteps.push(5);
            }
            
            // Enable position input
            enablePositionInput();
            
            TrackerCore.updateStepIndicators();
            TrackerCore.saveState();
        }
        
        function displayOptimizationResults(results) {
            const container = document.getElementById('portfolio-optimization-results');
            if (!container) return;
            
            let html = `
                <h3>Optimization Results</h3>
                <div style="margin: 20px 0;">
                    <p>Selected ${results.optimization.selectedScenarios} scenarios covering ${(results.optimization.cumulativeProbability * 100).toFixed(1)}% probability</p>
                    <p>Max Regret: ${(results.optimization.maxRegret * 100).toFixed(2)}% | Weighted Regret: ${(results.optimization.weightedRegret * 100).toFixed(2)}%</p>
                </div>
                <div class="allocation-grid">
            `;
            
            const sortedAllocation = Object.entries(results.finalAllocation)
                .sort(([,a], [,b]) => b - a)
                .filter(([,weight]) => weight > 0.005);
            
            sortedAllocation.forEach(([security, weight]) => {
                html += `
                    <div class="allocation-item">
                        <div class="allocation-symbol">${security}</div>
                        <div class="allocation-percent">${(weight * 100).toFixed(1)}%</div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function enablePositionInput() {
            const container = document.getElementById('position-input-container');
            if (!container) return;
            
            // Position input interface would go here
            container.innerHTML = `
                <p>Position input interface will be displayed here.</p>
                <p>This feature allows you to enter your current portfolio positions.</p>
            `;
        }
        
        function saveIndicatorEdit() {
            // Implementation for saving manual edits
            console.log('Saving indicator edit...');
            DataEditor.closeEditModal();
        }
        
        // Initialize application
        window.addEventListener('load', () => {
            TrackerCore.init();
            console.log('HCP Tracker v7.0 initialized - 81 Ternary Scenarios');
        });
    </script>
</body>
</html>