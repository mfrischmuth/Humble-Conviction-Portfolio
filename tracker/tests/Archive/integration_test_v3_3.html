<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HCP Integration Test v3.3 - Portfolio Optimization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .test-controls {
            padding: 30px;
            border-bottom: 2px solid #eee;
            background: #f8f9fa;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .scenario-input {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .scenario-input label {
            font-weight: 500;
            margin: 0;
            min-width: 60px;
        }

        .scenario-input input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #333;
        }

        .results-section {
            padding: 30px;
        }

        .step-results {
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
        }

        .step-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #333;
        }

        .step-header:hover {
            background: #e9ecef;
        }

        .step-content {
            padding: 20px;
            display: none;
        }

        .step-content.active {
            display: block;
        }

        .step-summary {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #495057;
        }

        .metric-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .allocation-display {
            margin-top: 20px;
        }

        .allocation-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .security-info {
            flex: 1;
        }

        .security-name {
            font-weight: 600;
            color: #333;
        }

        .security-desc {
            font-size: 0.85em;
            color: #6c757d;
        }

        .allocation-viz {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        .allocation-bar {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .allocation-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .allocation-text {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            color: #495057;
        }

        .regret-matrix {
            overflow-x: auto;
            margin-top: 15px;
        }

        .regret-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 500px;
        }

        .regret-table th,
        .regret-table td {
            padding: 8px 12px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .regret-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .regret-positive {
            background: #d1ecf1;
            color: #0c5460;
        }

        .regret-negative {
            background: #f8d7da;
            color: #721c24;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        .success-message {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .expand-toggle {
            font-size: 1.2em;
            color: #6c757d;
        }

        .test-scenarios {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .test-scenario-btn {
            background: #e9ecef;
            color: #495057;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .test-scenario-btn:hover {
            background: #dee2e6;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 8px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .scenario-grid {
                grid-template-columns: 1fr;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>HCP Integration Test v3.3</h1>
            <p>Portfolio Optimization - Regret Minimization Framework</p>
        </div>

        <div class="test-controls">
            <div class="control-group">
                <label>Test Scenarios (Quick Load)</label>
                <div class="test-scenarios">
                    <button class="test-scenario-btn" onclick="loadTestScenario('balanced')">Balanced Market</button>
                    <button class="test-scenario-btn" onclick="loadTestScenario('tech_boom')">Tech Boom</button>
                    <button class="test-scenario-btn" onclick="loadTestScenario('usd_decline')">USD Decline</button>
                    <button class="test-scenario-btn" onclick="loadTestScenario('pe_reversion')">P/E Reversion</button>
                    <button class="test-scenario-btn" onclick="loadTestScenario('international')">International</button>
                    <button class="test-scenario-btn" onclick="loadTestScenario('extreme_divergence')">Extreme Divergence</button>
                </div>
            </div>

            <div class="control-group">
                <label>16-Scenario Probability Matrix (Top 8 Shown - Edit as needed)</label>
                <div class="scenario-grid" id="scenario-inputs">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <div class="control-group">
                <button class="btn" onclick="runOptimization()">Run Portfolio Optimization</button>
                <button class="btn btn-secondary" onclick="clearResults()">Clear Results</button>
                <button class="btn btn-secondary" onclick="exportResults()">Export Results</button>
            </div>
        </div>

        <div class="results-section" id="results-section" style="display: none;">
            <h2>Optimization Results</h2>
            
            <div class="step-results">
                <div class="step-header" onclick="toggleStep('step1')">
                    <span>Step 1: Scenario Selection</span>
                    <span class="expand-toggle">▼</span>
                </div>
                <div class="step-content" id="step1">
                    <div id="step1-content"></div>
                </div>
            </div>

            <div class="step-results">
                <div class="step-header" onclick="toggleStep('step2')">
                    <span>Step 2: Individual Scenario Optimization</span>
                    <span class="expand-toggle">▼</span>
                </div>
                <div class="step-content" id="step2">
                    <div id="step2-content"></div>
                </div>
            </div>

            <div class="step-results">
                <div class="step-header" onclick="toggleStep('step3')">
                    <span>Step 3: Regret Matrix Calculation</span>
                    <span class="expand-toggle">▼</span>
                </div>
                <div class="step-content" id="step3">
                    <div id="step3-content"></div>
                </div>
            </div>

            <div class="step-results">
                <div class="step-header" onclick="toggleStep('step4')">
                    <span>Step 4: Dual Optimization</span>
                    <span class="expand-toggle">▼</span>
                </div>
                <div class="step-content" id="step4">
                    <div id="step4-content"></div>
                </div>
            </div>

            <div class="step-results">
                <div class="step-header" onclick="toggleStep('step5')">
                    <span>Step 5: Smart Hedging Protocol</span>
                    <span class="expand-toggle">▼</span>
                </div>
                <div class="step-content" id="step5">
                    <div id="step5-content"></div>
                </div>
            </div>

            <div class="step-results">
                <div class="step-header" onclick="toggleStep('step6')">
                    <span>Step 6: Final Validation & Results</span>
                    <span class="expand-toggle">▼</span>
                </div>
                <div class="step-content active" id="step6">
                    <div id="step6-content"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Load the PortfolioOptimizer module
        let optimizationResults = null;

        // Test scenario configurations
        const testScenarios = {
            balanced: [
                {id: 1, binary: '0000', probability: 0.15, name: 'Base Case'},
                {id: 5, binary: '0100', probability: 0.20, name: 'AI↑'},
                {id: 9, binary: '1000', probability: 0.18, name: 'USD↓'},
                {id: 13, binary: '1100', probability: 0.12, name: 'USD↓ + AI↑'},
                {id: 3, binary: '0010', probability: 0.10, name: 'P/E↓'},
                {id: 2, binary: '0001', probability: 0.08, name: 'INTL↑'},
                {id: 7, binary: '0110', probability: 0.07, name: 'AI↑ + P/E↓'},
                {id: 11, binary: '1010', probability: 0.06, name: 'USD↓ + P/E↓'}
            ],
            
            tech_boom: [
                {id: 5, binary: '0100', probability: 0.35, name: 'AI↑'},
                {id: 13, binary: '1100', probability: 0.25, name: 'USD↓ + AI↑'},
                {id: 7, binary: '0110', probability: 0.15, name: 'AI↑ + P/E↓'},
                {id: 1, binary: '0000', probability: 0.10, name: 'Base Case'},
                {id: 6, binary: '0101', probability: 0.08, name: 'AI↑ + INTL↑'},
                {id: 9, binary: '1000', probability: 0.04, name: 'USD↓'},
                {id: 3, binary: '0010', probability: 0.02, name: 'P/E↓'},
                {id: 2, binary: '0001', probability: 0.01, name: 'INTL↑'}
            ],
            
            usd_decline: [
                {id: 9, binary: '1000', probability: 0.30, name: 'USD↓'},
                {id: 11, binary: '1010', probability: 0.20, name: 'USD↓ + P/E↓'},
                {id: 13, binary: '1100', probability: 0.18, name: 'USD↓ + AI↑'},
                {id: 10, binary: '1001', probability: 0.12, name: 'USD↓ + INTL↑'},
                {id: 1, binary: '0000', probability: 0.08, name: 'Base Case'},
                {id: 2, binary: '0001', probability: 0.06, name: 'INTL↑'},
                {id: 5, binary: '0100', probability: 0.04, name: 'AI↑'},
                {id: 3, binary: '0010', probability: 0.02, name: 'P/E↓'}
            ],
            
            pe_reversion: [
                {id: 3, binary: '0010', probability: 0.25, name: 'P/E↓'},
                {id: 7, binary: '0110', probability: 0.20, name: 'AI↑ + P/E↓'},
                {id: 11, binary: '1010', probability: 0.18, name: 'USD↓ + P/E↓'},
                {id: 4, binary: '0011', probability: 0.15, name: 'P/E↓ + INTL↑'},
                {id: 1, binary: '0000', probability: 0.10, name: 'Base Case'},
                {id: 5, binary: '0100', probability: 0.06, name: 'AI↑'},
                {id: 9, binary: '1000', probability: 0.04, name: 'USD↓'},
                {id: 2, binary: '0001', probability: 0.02, name: 'INTL↑'}
            ],
            
            international: [
                {id: 2, binary: '0001', probability: 0.25, name: 'INTL↑'},
                {id: 10, binary: '1001', probability: 0.22, name: 'USD↓ + INTL↑'},
                {id: 6, binary: '0101', probability: 0.18, name: 'AI↑ + INTL↑'},
                {id: 4, binary: '0011', probability: 0.15, name: 'P/E↓ + INTL↑'},
                {id: 1, binary: '0000', probability: 0.08, name: 'Base Case'},
                {id: 9, binary: '1000', probability: 0.06, name: 'USD↓'},
                {id: 5, binary: '0100', probability: 0.04, name: 'AI↑'},
                {id: 3, binary: '0010', probability: 0.02, name: 'P/E↓'}
            ],
            
            extreme_divergence: [
                {id: 5, binary: '0100', probability: 0.40, name: 'AI↑'},
                {id: 3, binary: '0010', probability: 0.35, name: 'P/E↓'},
                {id: 16, binary: '1111', probability: 0.12, name: 'All Active'},
                {id: 1, binary: '0000', probability: 0.08, name: 'Base Case'},
                {id: 9, binary: '1000', probability: 0.03, name: 'USD↓'},
                {id: 2, binary: '0001', probability: 0.02, name: 'INTL↑'},
                {id: 7, binary: '0110', probability: 0.00, name: 'AI↑ + P/E↓'},
                {id: 11, binary: '1010', probability: 0.00, name: 'USD↓ + P/E↓'}
            ]
        };

        // Initialize the interface
        function initializeInterface() {
            createScenarioInputs();
            loadTestScenario('balanced'); // Default to balanced
        }

        // Create scenario input fields
        function createScenarioInputs() {
            const container = document.getElementById('scenario-inputs');
            container.innerHTML = '';
            
            // Show top 8 scenarios for editing
            for (let i = 1; i <= 8; i++) {
                const div = document.createElement('div');
                div.className = 'scenario-input';
                div.innerHTML = `
                    <label>S${i}:</label>
                    <input type="number" 
                           id="scenario-${i}" 
                           min="0" 
                           max="1" 
                           step="0.01" 
                           value="0.00"
                           placeholder="0.00">
                    <span id="name-${i}" style="font-size: 0.8em; color: #666;">Base Case</span>
                `;
                container.appendChild(div);
            }
        }

        // Load predefined test scenarios
        function loadTestScenario(scenarioName) {
            const scenarios = testScenarios[scenarioName];
            if (!scenarios) return;
            
            // Clear all inputs first
            for (let i = 1; i <= 8; i++) {
                document.getElementById(`scenario-${i}`).value = '0.00';
                document.getElementById(`name-${i}`).textContent = 'Inactive';
            }
            
            // Set the test scenario values
            scenarios.forEach((scenario, index) => {
                if (index < 8) { // Only show top 8
                    const inputId = index + 1;
                    document.getElementById(`scenario-${inputId}`).value = scenario.probability.toFixed(3);
                    document.getElementById(`name-${inputId}`).textContent = scenario.name;
                }
            });
            
            console.log(`Loaded test scenario: ${scenarioName}`);
        }

        // Run the portfolio optimization
        async function runOptimization() {
            console.log('Starting portfolio optimization...');
            
            // Collect scenario probabilities from inputs
            const scenarioProbabilities = [];
            let totalProbability = 0;
            
            for (let i = 1; i <= 16; i++) {
                let probability = 0;
                
                // Get probability from input (first 8) or set to 0
                if (i <= 8) {
                    const input = document.getElementById(`scenario-${i}`);
                    probability = parseFloat(input.value) || 0;
                }
                
                totalProbability += probability;
                
                // Create binary representation
                const binary = (i - 1).toString(2).padStart(4, '0');
                const activeThemes = [];
                if (binary[0] === '1') activeThemes.push('USD↓');
                if (binary[1] === '1') activeThemes.push('AI↑');
                if (binary[2] === '1') activeThemes.push('P/E↓');
                if (binary[3] === '1') activeThemes.push('INTL↑');
                
                scenarioProbabilities.push({
                    id: i,
                    binary: binary,
                    probability: probability,
                    name: activeThemes.length > 0 ? activeThemes.join(' + ') : 'Base Case'
                });
            }
            
            // Validation
            if (totalProbability < 0.5) {
                showError('Total probability is too low. Please ensure scenario probabilities sum to at least 50%.');
                return;
            }
            
            if (Math.abs(totalProbability - 1.0) > 0.1) {
                showWarning(`Total probability is ${(totalProbability*100).toFixed(1)}%. Consider normalizing to 100%.`);
            }
            
            // Show loading
            showLoading('Running 6-step portfolio optimization...');
            
            try {
                // Run the optimization
                optimizationResults = PortfolioOptimizer.optimizePortfolio(scenarioProbabilities);
                
                if (optimizationResults.performance.success) {
                    displayOptimizationResults(optimizationResults);
                    showSuccess(`Optimization completed successfully in ${optimizationResults.performance.executionTimeMs}ms`);
                } else {
                    showError(`Optimization failed: ${optimizationResults.performance.error}`);
                }
                
            } catch (error) {
                console.error('Optimization error:', error);
                showError(`Optimization failed: ${error.message}`);
            }
        }

        // Display comprehensive optimization results
        function displayOptimizationResults(results) {
            console.log('Displaying optimization results:', results);
            
            // Show results section
            document.getElementById('results-section').style.display = 'block';
            
            // Step 1: Scenario Selection
            displayStep1Results(results.steps.scenarioSelection);
            
            // Step 2: Individual Optimization
            displayStep2Results(results.steps.individualOptimization);
            
            // Step 3: Regret Matrix
            displayStep3Results(results.steps.regretMatrix);
            
            // Step 4: Dual Optimization
            displayStep4Results(results.steps.dualOptimization);
            
            // Step 5: Smart Hedging
            displayStep5Results(results.steps.smartHedging);
            
            // Step 6: Final Results
            displayStep6Results(results);
            
            // Scroll to results
            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        }

        // Display Step 1 Results
        function displayStep1Results(step1) {
            const container = document.getElementById('step1-content');
            const selection = step1.selectionCriteria;
            
            container.innerHTML = `
                <div class="step-summary">
                    <strong>Selected ${step1.scenarios.length} scenarios</strong> representing 
                    ${(step1.cumulativeProbability*100).toFixed(1)}% cumulative probability
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${step1.scenarios.length}</div>
                        <div class="metric-label">Scenarios Selected</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(selection.actualCumulative*100).toFixed(1)}%</div>
                        <div class="metric-label">Cumulative Probability</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${selection.targetCumulative*100}%</div>
                        <div class="metric-label">Target Cumulative</div>
                    </div>
                </div>
                
                <div class="allocation-display">
                    <h4>Selected Scenarios:</h4>
                    ${step1.scenarios.map(s => `
                        <div class="allocation-row">
                            <div class="security-info">
                                <div class="security-name">S${s.id} (${s.binary})</div>
                                <div class="security-desc">${s.name}</div>
                            </div>
                            <div class="allocation-viz">
                                <div class="allocation-bar">
                                    <div class="allocation-fill" style="width: ${s.probability*500}px; background: #007bff;"></div>
                                </div>
                                <div class="allocation-text">${(s.probability*100).toFixed(2)}%</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Display Step 2 Results  
        function displayStep2Results(step2) {
            const container = document.getElementById('step2-content');
            const scenarios = Object.keys(step2);
            
            let html = `
                <div class="step-summary">
                    <strong>Created optimal allocations</strong> for each of the ${scenarios.length} selected scenarios
                    using theme-based tilts and IPS v3.10 constraints
                </div>
            `;
            
            scenarios.forEach(scenarioId => {
                const allocation = step2[scenarioId];
                const sortedAllocations = Object.entries(allocation)
                    .sort(([,a], [,b]) => b - a)
                    .filter(([,weight]) => weight > 0.005);
                
                html += `
                    <div style="margin: 20px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 6px;">
                        <h4>Scenario ${scenarioId} Optimal Allocation</h4>
                        <div class="allocation-display">
                            ${sortedAllocations.map(([security, weight]) => `
                                <div class="allocation-row" style="padding: 5px 0;">
                                    <div class="security-info">
                                        <span class="security-name">${security}</span>
                                    </div>
                                    <div class="allocation-viz">
                                        <div class="allocation-bar">
                                            <div class="allocation-fill" style="width: ${weight*300}px; background: ${getSecurityColor(security)};"></div>
                                        </div>
                                        <div class="allocation-text">${(weight*100).toFixed(1)}%</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // Display Step 3 Results
        function displayStep3Results(step3) {
            const container = document.getElementById('step3-content');
            const summary = step3.summary;
            const regretMatrix = step3.regretMatrix;
            
            // Create regret matrix table
            const scenarios = Object.keys(summary);
            const scenarioIds = scenarios.map(s => parseInt(s)).sort((a,b) => a-b);
            
            let matrixHtml = `
                <div class="step-summary">
                    <strong>Calculated regret matrix</strong> showing how each scenario-optimized portfolio performs 
                    across all ${scenarios.length} scenarios
                </div>
                
                <div class="regret-matrix">
                    <table class="regret-table">
                        <thead>
                            <tr>
                                <th>Portfolio \\ Scenario</th>
                                ${scenarioIds.map(id => `<th>S${id}</th>`).join('')}
                                <th>Max Regret</th>
                                <th>Weighted Regret</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            scenarioIds.forEach(portfolioId => {
                const portfolioSummary = summary[portfolioId];
                matrixHtml += `<tr>`;
                matrixHtml += `<td><strong>S${portfolioId} Portfolio</strong></td>`;
                
                scenarioIds.forEach(scenarioId => {
                    const regret = regretMatrix[portfolioId][scenarioId];
                    const regretPercent = (regret * 100).toFixed(2);
                    const cellClass = regret >= 0 ? 'regret-positive' : 'regret-negative';
                    matrixHtml += `<td class="${cellClass}">${regretPercent}%</td>`;
                });
                
                matrixHtml += `<td class="regret-negative"><strong>${(portfolioSummary.maxRegret*100).toFixed(2)}%</strong></td>`;
                matrixHtml += `<td class="regret-negative">${(portfolioSummary.weightedRegret*100).toFixed(2)}%</td>`;
                matrixHtml += `</tr>`;
            });
            
            matrixHtml += `</tbody></table></div>`;
            
            container.innerHTML = matrixHtml;
        }

        // Display Step 4 Results
        function displayStep4Results(step4) {
            const container = document.getElementById('step4-content');
            
            container.innerHTML = `
                <div class="step-summary">
                    <strong>Found optimal balance</strong> using α = ${step4.alpha} to minimize both maximum regret 
                    and probability-weighted regret
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${step4.alpha}</div>
                        <div class="metric-label">Optimal α Parameter</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${step4.score.toFixed(4)}</div>
                        <div class="metric-label">Dual Optimization Score</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(step4.maxRegret*100).toFixed(2)}%</div>
                        <div class="metric-label">Maximum Regret</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(step4.weightedRegret*100).toFixed(2)}%</div>
                        <div class="metric-label">Weighted Regret</div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <h4>Selected Portfolio: Scenario ${step4.allocation}</h4>
                    <p><strong>Dual Score Formula:</strong> ${step4.alpha} × |Max Regret| + ${(1-step4.alpha)} × |Weighted Regret|</p>
                    <p><strong>Calculation:</strong> ${step4.alpha} × ${Math.abs(step4.maxRegret*100).toFixed(2)}% + ${(1-step4.alpha)} × ${Math.abs(step4.weightedRegret*100).toFixed(2)}% = ${step4.score.toFixed(4)}</p>
                </div>
            `;
        }

        // Display Step 5 Results
        function displayStep5Results(step5) {
            const container = document.getElementById('step5-content');
            
            let html = `
                <div class="step-summary">
                    <strong>Smart hedging assessment:</strong> 
                    ${step5.hedgingApplied ? 'Hedging applied to reduce regret' : 'No hedging needed - regret within tolerance'}
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${step5.hedgingApplied ? 'Yes' : 'No'}</div>
                        <div class="metric-label">Hedging Applied</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(step5.regretTolerance*100).toFixed(1)}%</div>
                        <div class="metric-label">Regret Tolerance</div>
                    </div>
            `;
            
            if (step5.hedgingApplied) {
                html += `
                    <div class="metric-card">
                        <div class="metric-value">${(step5.originalMaxRegret*100).toFixed(2)}%</div>
                        <div class="metric-label">Original Max Regret</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(step5.hedgeAmount*100).toFixed(1)}%</div>
                        <div class="metric-label">Hedge Amount</div>
                    </div>
                `;
            } else {
                html += `
                    <div class="metric-card">
                        <div class="metric-value">${(step5.maxRegret*100).toFixed(2)}%</div>
                        <div class="metric-label">Current Max Regret</div>
                    </div>
                `;
            }
            
            html += `</div>`;
            
            if (step5.hedgingApplied) {
                html += `
                    <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px;">
                        <h4>Hedging Details</h4>
                        <p><strong>Reason:</strong> ${step5.hedgingReason}</p>
                        <p><strong>Strategy:</strong> Added ${(step5.hedgeAmount*100).toFixed(1)}% hedge position to reduce portfolio regret</p>
                        <p><strong>Impact:</strong> Regret reduced from ${(step5.originalMaxRegret*100).toFixed(2)}% to within tolerance</p>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        // Display Step 6 Results (Final)
        function displayStep6Results(results) {
            const container = document.getElementById('step6-content');
            const allocation = results.finalAllocation;
            const optimization = results.optimization;
            const validation = results.steps.finalValidation;
            
            // Sort allocations by weight
            const sortedAllocations = Object.entries(allocation)
                .sort(([,a], [,b]) => b - a)
                .filter(([,weight]) => weight > 0.005);
            
            // Calculate sector weights
            const sectorWeights = calculateSectorWeights(allocation);
            
            let html = `
                <div class="step-summary">
                    <strong>Final portfolio allocation</strong> - Validation ${validation.validationPassed ? 'PASSED' : 'FAILED'} 
                    with ${optimization.selectedScenarios} scenarios (${(optimization.cumulativeProbability*100).toFixed(1)}% coverage)
                </div>
            `;
            
            if (!validation.validationPassed) {
                html += `
                    <div class="error-message">
                        <h4>Validation Issues:</h4>
                        <ul>
                            ${validation.constraintViolations.map(violation => `<li>${violation}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            html += `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${optimization.optimalAlpha}</div>
                        <div class="metric-label">Optimal α</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(optimization.maxRegret*100).toFixed(2)}%</div>
                        <div class="metric-label">Final Max Regret</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(optimization.weightedRegret*100).toFixed(2)}%</div>
                        <div class="metric-label">Weighted Regret</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${optimization.hedgingApplied ? 'Yes' : 'No'}</div>
                        <div class="metric-label">Hedging Applied</div>
                    </div>
                </div>
                
                <div class="allocation-display">
                    <h4>Final Portfolio Allocation</h4>
                    ${sortedAllocations.map(([security, weight]) => `
                        <div class="allocation-row">
                            <div class="security-info">
                                <div class="security-name">${security}</div>
                                <div class="security-desc">${getSecurityDescription(security)}</div>
                            </div>
                            <div class="allocation-viz">
                                <div class="allocation-bar">
                                    <div class="allocation-fill" style="width: ${weight*300}px; background: ${getSecurityColor(security)};"></div>
                                </div>
                                <div class="allocation-text">${(weight*100).toFixed(1)}%</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="metrics-grid" style="margin-top: 30px;">
                    <div class="metric-card">
                        <div class="metric-value">${(sectorWeights.equity*100).toFixed(1)}%</div>
                        <div class="metric-label">Equity Exposure</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(sectorWeights.income*100).toFixed(1)}%</div>
                        <div class="metric-label">Income Exposure</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(sectorWeights.alternative*100).toFixed(1)}%</div>
                        <div class="metric-label">Alternatives</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${(sectorWeights.cash*100).toFixed(1)}%</div>
                        <div class="metric-label">Cash</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        // Utility functions
        function getSecurityColor(security) {
            const colors = {
                VTI: '#007bff', VEA: '#007bff', VWO: '#007bff', SMH: '#007bff', SRVR: '#007bff',
                PIMIX: '#28a745', PYLD: '#28a745',
                GLD: '#ffc107', COM: '#ffc107', IGF: '#ffc107', DBMF: '#ffc107',
                SWVXX: '#6c757d'
            };
            return colors[security] || '#dee2e6';
        }

        function getSecurityDescription(security) {
            const descriptions = {
                VTI: 'US Total Market',
                VEA: 'Developed International', 
                VWO: 'Emerging Markets',
                SMH: 'Semiconductors',
                SRVR: 'Infrastructure/Data Centers',
                PIMIX: 'PIMCO Income Fund',
                PYLD: 'PIMCO Yield Opportunities',
                GLD: 'Gold',
                COM: 'Commodities',
                IGF: 'Global Infrastructure',
                DBMF: 'Managed Futures',
                SWVXX: 'Money Market'
            };
            return descriptions[security] || 'Unknown Security';
        }

        function calculateSectorWeights(allocation) {
            const sectors = { equity: 0, income: 0, alternative: 0, cash: 0 };
            const securityTypes = {
                VTI: 'equity', VEA: 'equity', VWO: 'equity', SMH: 'equity', SRVR: 'equity',
                PIMIX: 'income', PYLD: 'income',
                GLD: 'alternative', COM: 'alternative', IGF: 'alternative', DBMF: 'alternative',
                SWVXX: 'cash'
            };
            
            for (const [security, weight] of Object.entries(allocation)) {
                const type = securityTypes[security];
                if (type) sectors[type] += weight;
            }
            
            return sectors;
        }

        // UI utility functions
        function toggleStep(stepId) {
            const content = document.getElementById(stepId);
            const header = content.previousElementSibling.querySelector('.expand-toggle');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                header.textContent = '▼';
            } else {
                content.classList.add('active');
                header.textContent = '▲';
            }
        }

        function showLoading(message) {
            const container = document.getElementById('results-section');
            container.style.display = 'block';
            container.innerHTML = `<div class="loading">${message}</div>`;
        }

        function showError(message) {
            const container = document.getElementById('results-section');
            container.style.display = 'block';
            container.innerHTML = `<div class="error-message">${message}</div>`;
        }

        function showWarning(message) {
            console.warn(message);
            // Could add a warning display to UI
        }

        function showSuccess(message) {
            console.log(message);
            // Success is shown through results display
        }

        function clearResults() {
            document.getElementById('results-section').style.display = 'none';
            optimizationResults = null;
        }

        function exportResults() {
            if (!optimizationResults) {
                alert('No results to export. Please run an optimization first.');
                return;
            }
            
            const exportData = {
                timestamp: new Date().toISOString(),
                version: 'Integration Test v3.3',
                optimizer: optimizationResults.version,
                results: optimizationResults
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hcp_optimization_results_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeInterface);
    </script>
    
    <!-- Load PortfolioOptimizer module -->
    <script>
        // Embed the PortfolioOptimizer v2.0 directly since we can't import external files
        /**
 * HCP Portfolio Optimizer v2.0 - Regret Minimization Framework
 * File: portfolio_optimizer_v2_0.js
 * Based on: IPS v3.10 Complete Implementation Framework
 * Last Updated: 2025-09-02 21:00:00 UTC
 * 
 * IMPLEMENTS SOPHISTICATED REGRET MINIMIZATION:
 * - 6-Step portfolio optimization process per IPS v3.10
 * - Dual optimization: α × Max_Regret + (1-α) × Weighted_Regret
 * - Smart hedging protocols with correlation assessment
 * - Complete 12-asset security universe from IPS v3.10
 * - Security-specific trading rules (PIMIX hold-only, PYLD primary income)
 * 
 * REPLACES: PortfolioOptimizer v1.0 (completely incorrect approach)
 * INTEGRATION: Designed for integration_test_v3_3.html then HCP Tracker v6.5.5+
 */

const PortfolioOptimizer = {
    version: '2.0',
    framework: 'IPS v3.10 Regret Minimization',
    lastUpdated: '2025-09-02T21:00:00.000Z',
    
    // IPS v3.10 Complete Security Universe (12 Assets)
    securities: {
        // Equity Exposures (5)
        VTI: { name: 'US Total Market', type: 'equity', category: 'us_equity' },
        VEA: { name: 'Developed International', type: 'equity', category: 'intl_equity' },
        VWO: { name: 'Emerging Markets', type: 'equity', category: 'intl_equity' },
        SMH: { name: 'Semiconductors', type: 'equity', category: 'tech_equity' },
        SRVR: { name: 'Infrastructure/Data Centers', type: 'equity', category: 'tech_equity' },
        
        // Income Exposures (2)
        PIMIX: { name: 'PIMCO Income Fund', type: 'income', category: 'income', holdOnly: true },
        PYLD: { name: 'PIMCO Yield Opportunities', type: 'income', category: 'income', primaryIncome: true },
        
        // Alternative Exposures (4)
        GLD: { name: 'Gold', type: 'alternative', category: 'commodities' },
        COM: { name: 'Commodities', type: 'alternative', category: 'commodities' },
        IGF: { name: 'Global Infrastructure', type: 'alternative', category: 'infrastructure' },
        DBMF: { name: 'Managed Futures', type: 'alternative', category: 'hedge' },
        
        // Cash (1)
        SWVXX: { name: 'Money Market', type: 'cash', category: 'cash' }
    },

    // IPS v3.10 Position Limits and Risk Constraints
    constraints: {
        maxSinglePosition: 0.35,        // 35% maximum single position
        maxSectorConcentration: 0.50,   // 50% maximum sector concentration
        minCashPosition: 0.01,          // 1% minimum cash
        maxAlternatives: 0.30,          // 30% maximum alternatives combined
        maxDBMF: 0.15,                  // 15% maximum DBMF (hedging limit)
        maxIncome: 0.30,                // 30% maximum combined income
        maxRegretTarget: {              // Variable based on correlation
            high: 0.05,                 // 5% max regret if correlation > 0.7
            medium: 0.06,               // 6% max regret if correlation 0.5-0.7
            low: 0.08                   // 8% max regret if correlation < 0.5
        }
    },

    // Theme-Based Portfolio Tilts (IPS v3.10 Specifications)
    themeTilts: {
        usd: {  // USD Dominance Decline theme
            name: 'USD Dominance Decline',
            positive: { VEA: 0.05, VWO: 0.05, GLD: 0.03, COM: 0.02 },  // Increase these
            negative: { VTI: -0.05, SWVXX: -0.10 }                      // Decrease these
        },
        ai: {   // AI Productivity Boom theme  
            name: 'AI Productivity Boom',
            positive: { SMH: 0.08, SRVR: 0.05, VTI: 0.02 },            // Increase tech
            negative: { VEA: -0.03, PYLD: -0.02 }                       // Decrease traditional
        },
        pe: {   // P/E Mean Reversion theme
            name: 'P/E Mean Reversion', 
            positive: { PYLD: 0.05, GLD: 0.03, SWVXX: 0.05 },          // Increase defensive
            negative: { SMH: -0.05, VTI: -0.03, VWO: -0.02 }           // Decrease growth
        },
        intl: { // International Outperformance theme
            name: 'International Outperformance',
            positive: { VEA: 0.08, VWO: 0.05, IGF: 0.02 },             // Increase international
            negative: { VTI: -0.10, SMH: -0.03, SRVR: -0.02 }          // Decrease US equity
        }
    },

    /**
     * STEP 1: SCENARIO SELECTION
     * Select scenarios for optimization based on IPS v3.10 criteria
     */
    selectScenariosForOptimization: function(scenarioProbabilities) {
        console.log('=== Step 1: Scenario Selection ===');
        
        // Sort scenarios by probability (highest first)
        const sortedScenarios = [...scenarioProbabilities].sort((a, b) => b.probability - a.probability);
        
        let selectedScenarios = [];
        let cumulativeProbability = 0;
        
        // Include until cumulative ≥ 85%
        for (const scenario of sortedScenarios) {
            selectedScenarios.push(scenario);
            cumulativeProbability += scenario.probability;
            
            if (cumulativeProbability >= 0.85 && selectedScenarios.length >= 3) {
                break;
            }
            
            // Maximum 6 scenarios
            if (selectedScenarios.length >= 6) {
                break;
            }
        }
        
        // Include any scenario ≥ 10% probability regardless
        for (const scenario of sortedScenarios) {
            if (scenario.probability >= 0.10 && !selectedScenarios.some(s => s.id === scenario.id)) {
                selectedScenarios.push(scenario);
            }
        }
        
        // Ensure minimum 3 scenarios
        if (selectedScenarios.length < 3) {
            selectedScenarios = sortedScenarios.slice(0, 3);
        }
        
        const finalCumulative = selectedScenarios.reduce((sum, s) => sum + s.probability, 0);
        
        console.log(`Selected ${selectedScenarios.length} scenarios (${(finalCumulative*100).toFixed(1)}% cumulative):`, 
                   selectedScenarios.map(s => `S${s.id}:${(s.probability*100).toFixed(1)}%`));
        
        return {
            scenarios: selectedScenarios,
            cumulativeProbability: finalCumulative,
            selectionCriteria: {
                targetCumulative: 0.85,
                actualCumulative: finalCumulative,
                minScenarios: 3,
                maxScenarios: 6,
                selectedCount: selectedScenarios.length
            }
        };
    },

    /**
     * STEP 2: INDIVIDUAL SCENARIO OPTIMIZATION
     * Create optimal allocation for each selected scenario with theme tilts
     */
    optimizeIndividualScenarios: function(selectedScenarios) {
        console.log('=== Step 2: Individual Scenario Optimization ===');
        
        const scenarioAllocations = {};
        
        for (const scenario of selectedScenarios) {
            const allocation = this.createScenarioOptimalAllocation(scenario);
            scenarioAllocations[scenario.id] = allocation;
            
            console.log(`S${scenario.id} optimal allocation:`, this.formatAllocationSummary(allocation));
        }
        
        return scenarioAllocations;
    },

    /**
     * Create optimal allocation for a specific scenario using theme tilts
     */
    createScenarioOptimalAllocation: function(scenario) {
        // Start with baseline allocation
        let allocation = this.getBaselineAllocation();
        
        // Apply theme tilts based on active themes in scenario
        const activeThemes = this.getActiveThemes(scenario);
        
        for (const themeKey of activeThemes) {
            if (this.themeTilts[themeKey]) {
                allocation = this.applyThemeTilt(allocation, this.themeTilts[themeKey]);
            }
        }
        
        // Apply constraints and normalize
        allocation = this.applyConstraints(allocation);
        allocation = this.normalizeAllocation(allocation);
        
        return allocation;
    },

    /**
     * Get baseline allocation (neutral scenario)
     */
    getBaselineAllocation: function() {
        return {
            VTI: 0.35,      // US equity core
            VEA: 0.20,      // International developed
            VWO: 0.10,      // Emerging markets
            SMH: 0.08,      // Tech/semiconductors
            SRVR: 0.05,     // Infrastructure
            PYLD: 0.12,     // Primary income
            PIMIX: 0.03,    // Legacy income (hold-only)
            GLD: 0.02,      // Gold hedge
            COM: 0.01,      // Commodities
            IGF: 0.02,      // Infrastructure
            DBMF: 0.01,     // Managed futures
            SWVXX: 0.01     // Cash minimum
        };
    },

    /**
     * Determine active themes from scenario binary representation
     */
    getActiveThemes: function(scenario) {
        const activeThemes = [];
        
        // Parse scenario binary (format: ABCD where A=USD, B=AI, C=PE, D=INTL)
        const binary = scenario.binary || scenario.id.toString(2).padStart(4, '0');
        
        if (binary[0] === '1') activeThemes.push('usd');   // USD Decline active
        if (binary[1] === '1') activeThemes.push('ai');    // AI Boom active
        if (binary[2] === '1') activeThemes.push('pe');    // P/E Reversion active
        if (binary[3] === '1') activeThemes.push('intl');  // International active
        
        return activeThemes;
    },

    /**
     * Apply theme tilt to allocation
     */
    applyThemeTilt: function(allocation, tilt) {
        const newAllocation = {...allocation};
        
        // Apply positive tilts
        for (const [security, tiltAmount] of Object.entries(tilt.positive || {})) {
            if (newAllocation[security] !== undefined) {
                newAllocation[security] += tiltAmount;
            }
        }
        
        // Apply negative tilts
        for (const [security, tiltAmount] of Object.entries(tilt.negative || {})) {
            if (newAllocation[security] !== undefined) {
                newAllocation[security] += tiltAmount; // tiltAmount is already negative
            }
        }
        
        return newAllocation;
    },

    /**
     * STEP 3: REGRET MATRIX CALCULATION
     * Calculate regret for each allocation across all scenarios
     */
    calculateRegretMatrix: function(scenarioAllocations, selectedScenarios) {
        console.log('=== Step 3: Regret Matrix Calculation ===');
        
        const regretMatrix = {};
        const returnMatrix = {};
        
        // Calculate expected returns for each allocation in each scenario
        for (const [allocId, allocation] of Object.entries(scenarioAllocations)) {
            returnMatrix[allocId] = {};
            regretMatrix[allocId] = {};
            
            for (const scenario of selectedScenarios) {
                const expectedReturn = this.calculateExpectedReturn(allocation, scenario);
                returnMatrix[allocId][scenario.id] = expectedReturn;
            }
        }
        
        // Calculate regret: Return(portfolio, scenario) - Return(optimal_for_scenario, scenario)
        for (const [allocId, allocation] of Object.entries(scenarioAllocations)) {
            for (const scenario of selectedScenarios) {
                const portfolioReturn = returnMatrix[allocId][scenario.id];
                const optimalReturn = returnMatrix[scenario.id][scenario.id]; // Scenario's own optimal return
                const regret = portfolioReturn - optimalReturn;
                
                regretMatrix[allocId][scenario.id] = regret;
            }
        }
        
        // Calculate summary statistics
        const regretSummary = this.calculateRegretSummary(regretMatrix, selectedScenarios);
        
        console.log('Regret Matrix Summary:', regretSummary);
        
        return {
            regretMatrix: regretMatrix,
            returnMatrix: returnMatrix,
            summary: regretSummary
        };
    },

    /**
     * Calculate expected return for allocation in specific scenario
     */
    calculateExpectedReturn: function(allocation, scenario) {
        // Simplified expected return calculation based on theme strength
        // In production, this would use detailed asset return models
        
        const activeThemes = this.getActiveThemes(scenario);
        let expectedReturn = 0.08; // Base 8% return assumption
        
        // Theme-based return adjustments
        const themeReturns = {
            usd: { VEA: 0.03, VWO: 0.04, GLD: 0.15, COM: 0.08, VTI: -0.02 },
            ai: { SMH: 0.18, SRVR: 0.12, VTI: 0.03, VEA: -0.01 },
            pe: { PYLD: 0.06, GLD: 0.08, SWVXX: 0.02, SMH: -0.08, VTI: -0.05 },
            intl: { VEA: 0.08, VWO: 0.12, IGF: 0.06, VTI: -0.03, SMH: -0.02 }
        };
        
        let themeAdjustment = 0;
        for (const theme of activeThemes) {
            if (themeReturns[theme]) {
                for (const [security, weight] of Object.entries(allocation)) {
                    const themeReturn = themeReturns[theme][security] || 0;
                    themeAdjustment += weight * themeReturn;
                }
            }
        }
        
        return expectedReturn + themeAdjustment;
    },

    /**
     * Calculate regret matrix summary statistics
     */
    calculateRegretSummary: function(regretMatrix, selectedScenarios) {
        const summary = {};
        
        for (const [allocId, regrets] of Object.entries(regretMatrix)) {
            const regretValues = Object.values(regrets);
            const maxRegret = Math.min(...regretValues); // Most negative = worst regret
            
            // Probability-weighted regret
            let weightedRegret = 0;
            for (const scenario of selectedScenarios) {
                weightedRegret += scenario.probability * regrets[scenario.id];
            }
            
            summary[allocId] = {
                maxRegret: maxRegret,
                weightedRegret: weightedRegret,
                regretRange: Math.max(...regretValues) - Math.min(...regretValues),
                scenarios: regrets
            };
        }
        
        return summary;
    },

    /**
     * STEP 4: DUAL OPTIMIZATION
     * Find optimal α parameter and blended allocation
     */
    runDualOptimization: function(regretMatrix, selectedScenarios, regretSummary) {
        console.log('=== Step 4: Dual Optimization ===');
        
        const alphaRange = [0.3, 0.4, 0.5, 0.6, 0.7]; // Test alpha values
        let bestResult = null;
        let bestScore = Infinity;
        
        for (const alpha of alphaRange) {
            let bestAllocForAlpha = null;
            let bestScoreForAlpha = Infinity;
            
            // Test each scenario allocation with this alpha
            for (const [allocId, summary] of Object.entries(regretSummary)) {
                const dualScore = alpha * Math.abs(summary.maxRegret) + (1 - alpha) * Math.abs(summary.weightedRegret);
                
                if (dualScore < bestScoreForAlpha) {
                    bestScoreForAlpha = dualScore;
                    bestAllocForAlpha = allocId;
                }
            }
            
            if (bestScoreForAlpha < bestScore) {
                bestScore = bestScoreForAlpha;
                bestResult = {
                    alpha: alpha,
                    allocation: bestAllocForAlpha,
                    score: bestScoreForAlpha,
                    maxRegret: regretSummary[bestAllocForAlpha].maxRegret,
                    weightedRegret: regretSummary[bestAllocForAlpha].weightedRegret
                };
            }
        }
        
        console.log(`Best dual optimization result: α=${bestResult.alpha}, Score=${bestResult.score.toFixed(4)}`);
        console.log(`Max Regret: ${(bestResult.maxRegret*100).toFixed(2)}%, Weighted Regret: ${(bestResult.weightedRegret*100).toFixed(2)}%`);
        
        return bestResult;
    },

    /**
     * STEP 5: SMART HEDGING PROTOCOL
     * Apply smart hedging if regret exceeds tolerance
     */
    applySmartHedging: function(dualOptResult, scenarioAllocations, selectedScenarios) {
        console.log('=== Step 5: Smart Hedging Protocol ===');
        
        let finalAllocation = scenarioAllocations[dualOptResult.allocation];
        const maxRegretPercent = Math.abs(dualOptResult.maxRegret);
        
        // Assess portfolio correlation
        const correlation = this.assessPortfolioCorrelation(scenarioAllocations, selectedScenarios);
        let regretTolerance;
        
        if (correlation > 0.7) {
            regretTolerance = this.constraints.maxRegretTarget.high; // 5%
        } else if (correlation > 0.5) {
            regretTolerance = this.constraints.maxRegretTarget.medium; // 6%
        } else {
            regretTolerance = this.constraints.maxRegretTarget.low; // 8%
        }
        
        console.log(`Portfolio correlation: ${correlation.toFixed(3)}, Regret tolerance: ${(regretTolerance*100).toFixed(1)}%`);
        console.log(`Current max regret: ${(maxRegretPercent*100).toFixed(2)}%`);
        
        if (maxRegretPercent > regretTolerance) {
            console.log('Regret exceeds tolerance - applying smart hedging');
            
            const hedgingResult = this.determineHedgingStrategy(selectedScenarios, finalAllocation);
            finalAllocation = this.applyHedging(finalAllocation, hedgingResult);
            
            return {
                allocation: finalAllocation,
                hedgingApplied: true,
                hedgingReason: hedgingResult.reason,
                hedgeAmount: hedgingResult.amount,
                regretTolerance: regretTolerance,
                originalMaxRegret: maxRegretPercent
            };
        }
        
        return {
            allocation: finalAllocation,
            hedgingApplied: false,
            regretTolerance: regretTolerance,
            maxRegret: maxRegretPercent
        };
    },

    /**
     * Assess correlation between scenario allocations
     */
    assessPortfolioCorrelation: function(scenarioAllocations, selectedScenarios) {
        const allocations = selectedScenarios.map(s => scenarioAllocations[s.id]);
        const securities = Object.keys(this.securities);
        
        let totalCorrelation = 0;
        let pairCount = 0;
        
        for (let i = 0; i < allocations.length; i++) {
            for (let j = i + 1; j < allocations.length; j++) {
                const corr = this.calculateAllocationCorrelation(allocations[i], allocations[j], securities);
                totalCorrelation += corr;
                pairCount++;
            }
        }
        
        return pairCount > 0 ? totalCorrelation / pairCount : 0;
    },

    /**
     * Calculate correlation between two allocations
     */
    calculateAllocationCorrelation: function(alloc1, alloc2, securities) {
        const values1 = securities.map(s => alloc1[s] || 0);
        const values2 = securities.map(s => alloc2[s] || 0);
        
        const mean1 = values1.reduce((sum, v) => sum + v, 0) / values1.length;
        const mean2 = values2.reduce((sum, v) => sum + v, 0) / values2.length;
        
        let numerator = 0;
        let sumSquares1 = 0;
        let sumSquares2 = 0;
        
        for (let i = 0; i < values1.length; i++) {
            const diff1 = values1[i] - mean1;
            const diff2 = values2[i] - mean2;
            numerator += diff1 * diff2;
            sumSquares1 += diff1 * diff1;
            sumSquares2 += diff2 * diff2;
        }
        
        const denominator = Math.sqrt(sumSquares1 * sumSquares2);
        return denominator > 0 ? numerator / denominator : 0;
    },

    /**
     * Determine appropriate hedging strategy
     */
    determineHedgingStrategy: function(selectedScenarios, allocation) {
        // Analyze scenario divergence to determine hedge type
        const geographicDivergence = this.assessGeographicDivergence(selectedScenarios);
        const volatilityDivergence = this.assessVolatilityDivergence(selectedScenarios);
        const assetClassDivergence = this.assessAssetClassDivergence(selectedScenarios);
        
        if (volatilityDivergence > 0.6) {
            return { type: 'volatility', hedge: 'DBMF', amount: 0.05, reason: 'High volatility divergence' };
        } else if (geographicDivergence > 0.5) {
            return { type: 'geographic', hedge: 'VEA', amount: 0.03, reason: 'Geographic divergence' };
        } else if (assetClassDivergence > 0.5) {
            return { type: 'asset_class', hedge: 'IGF', amount: 0.03, reason: 'Asset class divergence' };
        } else {
            return { type: 'cash', hedge: 'SWVXX', amount: 0.02, reason: 'Irreconcilable scenarios' };
        }
    },

    /**
     * Assess geographic divergence between scenarios
     */
    assessGeographicDivergence: function(scenarios) {
        // Simple heuristic based on international theme prevalence
        const intlActive = scenarios.filter(s => this.getActiveThemes(s).includes('intl')).length;
        return intlActive / scenarios.length;
    },

    /**
     * Assess volatility divergence between scenarios
     */
    assessVolatilityDivergence: function(scenarios) {
        // Heuristic based on theme combinations that create volatility
        let volatilityScenarios = 0;
        for (const scenario of scenarios) {
            const themes = this.getActiveThemes(scenario);
            if (themes.length >= 3 || themes.includes('ai') && themes.includes('pe')) {
                volatilityScenarios++;
            }
        }
        return volatilityScenarios / scenarios.length;
    },

    /**
     * Assess asset class divergence
     */
    assessAssetClassDivergence: function(scenarios) {
        // Heuristic based on defensive vs growth theme conflicts
        let conflictScenarios = 0;
        for (const scenario of scenarios) {
            const themes = this.getActiveThemes(scenario);
            if (themes.includes('ai') && themes.includes('pe')) {
                conflictScenarios++; // Growth vs defensive conflict
            }
        }
        return conflictScenarios / scenarios.length;
    },

    /**
     * Apply hedging to allocation
     */
    applyHedging: function(allocation, hedgingResult) {
        const newAllocation = {...allocation};
        const hedgeAmount = hedgingResult.amount;
        const hedgeSecurity = hedgingResult.hedge;
        
        // Add hedge position
        newAllocation[hedgeSecurity] = (newAllocation[hedgeSecurity] || 0) + hedgeAmount;
        
        // Reduce other positions proportionally
        const totalToReduce = hedgeAmount;
        const nonHedgeTotal = 1 - (newAllocation[hedgeSecurity] || 0);
        
        for (const [security, weight] of Object.entries(newAllocation)) {
            if (security !== hedgeSecurity && weight > 0) {
                const reduction = (weight / nonHedgeTotal) * totalToReduce;
                newAllocation[security] = Math.max(0, weight - reduction);
            }
        }
        
        return this.normalizeAllocation(newAllocation);
    },

    /**
     * STEP 6: FINAL VALIDATION
     * Apply constraints and validate final allocation
     */
    validateFinalAllocation: function(allocation, hedgingResult) {
        console.log('=== Step 6: Final Validation ===');
        
        let validatedAllocation = {...allocation};
        const validationResults = {
            constraintViolations: [],
            adjustmentsMade: [],
            finalAllocation: null,
            validationPassed: true
        };
        
        // Apply all constraints
        validatedAllocation = this.applyConstraints(validatedAllocation);
        
        // Check position limits
        for (const [security, weight] of Object.entries(validatedAllocation)) {
            if (weight > this.constraints.maxSinglePosition) {
                validationResults.constraintViolations.push(
                    `${security} exceeds max position limit: ${(weight*100).toFixed(1)}% > ${(this.constraints.maxSinglePosition*100).toFixed(1)}%`
                );
            }
        }
        
        // Check sector concentrations
        const sectorWeights = this.calculateSectorWeights(validatedAllocation);
        for (const [sector, weight] of Object.entries(sectorWeights)) {
            if (weight > this.constraints.maxSectorConcentration) {
                validationResults.constraintViolations.push(
                    `${sector} sector exceeds concentration limit: ${(weight*100).toFixed(1)}% > ${(this.constraints.maxSectorConcentration*100).toFixed(1)}%`
                );
            }
        }
        
        // Ensure normalization
        validatedAllocation = this.normalizeAllocation(validatedAllocation);
        
        validationResults.finalAllocation = validatedAllocation;
        validationResults.validationPassed = validationResults.constraintViolations.length === 0;
        
        console.log(`Validation ${validationResults.validationPassed ? 'PASSED' : 'FAILED'}`);
        if (validationResults.constraintViolations.length > 0) {
            console.log('Constraint violations:', validationResults.constraintViolations);
        }
        
        return validationResults;
    },

    /**
     * Apply position and risk constraints
     */
    applyConstraints: function(allocation) {
        let constrainedAllocation = {...allocation};
        
        // Apply maximum single position constraint
        for (const security of Object.keys(constrainedAllocation)) {
            if (constrainedAllocation[security] > this.constraints.maxSinglePosition) {
                constrainedAllocation[security] = this.constraints.maxSinglePosition;
            }
        }
        
        // Ensure minimum cash position
        if (constrainedAllocation.SWVXX < this.constraints.minCashPosition) {
            constrainedAllocation.SWVXX = this.constraints.minCashPosition;
        }
        
        // Apply PIMIX hold-only constraint
        if (this.securities.PIMIX.holdOnly && constrainedAllocation.PIMIX > 0.05) {
            // Don't increase PIMIX beyond small existing position
            constrainedAllocation.PIMIX = Math.min(constrainedAllocation.PIMIX, 0.05);
        }
        
        // Ensure non-negative allocations
        for (const security of Object.keys(constrainedAllocation)) {
            constrainedAllocation[security] = Math.max(0, constrainedAllocation[security]);
        }
        
        return constrainedAllocation;
    },

    /**
     * Calculate sector weights for concentration limits
     */
    calculateSectorWeights: function(allocation) {
        const sectorWeights = {
            equity: 0,
            income: 0,
            alternatives: 0,
            cash: 0
        };
        
        for (const [security, weight] of Object.entries(allocation)) {
            const securityInfo = this.securities[security];
            if (securityInfo) {
                sectorWeights[securityInfo.type] += weight;
            }
        }
        
        return sectorWeights;
    },

    /**
     * Normalize allocation to sum to 100%
     */
    normalizeAllocation: function(allocation) {
        const total = Object.values(allocation).reduce((sum, weight) => sum + weight, 0);
        
        if (total === 0) {
            return this.getBaselineAllocation(); // Fallback if everything is zero
        }
        
        const normalized = {};
        for (const [security, weight] of Object.entries(allocation)) {
            normalized[security] = weight / total;
        }
        
        return normalized;
    },

    /**
     * MAIN OPTIMIZATION ENTRY POINT
     * Execute complete 6-step portfolio optimization process
     */
    optimizePortfolio: function(scenarioProbabilities, options = {}) {
        console.log('=== HCP Portfolio Optimizer v2.0 - Starting Regret Minimization ===');
        console.log('Input scenarios:', scenarioProbabilities.length);
        
        const startTime = Date.now();
        const results = {
            version: this.version,
            framework: this.framework,
            timestamp: new Date().toISOString(),
            inputs: {
                scenarios: scenarioProbabilities.length,
                options: options
            },
            steps: {},
            performance: {}
        };
        
        try {
            // Step 1: Scenario Selection
            const step1 = this.selectScenariosForOptimization(scenarioProbabilities);
            results.steps.scenarioSelection = step1;
            
            // Step 2: Individual Scenario Optimization
            const step2 = this.optimizeIndividualScenarios(step1.scenarios);
            results.steps.individualOptimization = step2;
            
            // Step 3: Regret Matrix Calculation
            const step3 = this.calculateRegretMatrix(step2, step1.scenarios);
            results.steps.regretMatrix = step3;
            
            // Step 4: Dual Optimization
            const step4 = this.runDualOptimization(step3.regretMatrix, step1.scenarios, step3.summary);
            results.steps.dualOptimization = step4;
            
            // Step 5: Smart Hedging Protocol
            const step5 = this.applySmartHedging(step4, step2, step1.scenarios);
            results.steps.smartHedging = step5;
            
            // Step 6: Final Validation
            const step6 = this.validateFinalAllocation(step5.allocation, step5);
            results.steps.finalValidation = step6;
            
            // Final results
            results.finalAllocation = step6.finalAllocation;
            results.optimization = {
                selectedScenarios: step1.scenarios.length,
                cumulativeProbability: step1.cumulativeProbability,
                optimalAlpha: step4.alpha,
                maxRegret: step4.maxRegret,
                weightedRegret: step4.weightedRegret,
                hedgingApplied: step5.hedgingApplied,
                validationPassed: step6.validationPassed
            };
            
            results.performance.executionTimeMs = Date.now() - startTime;
            results.performance.success = true;
            
            console.log('=== Portfolio Optimization COMPLETED ===');
            console.log(`Execution time: ${results.performance.executionTimeMs}ms`);
            console.log('Final allocation:', this.formatAllocationSummary(results.finalAllocation));
            
            return results;
            
        } catch (error) {
            console.error('Portfolio optimization failed:', error);
            results.performance.success = false;
            results.performance.error = error.message;
            results.performance.executionTimeMs = Date.now() - startTime;
            return results;
        }
    },

    /**
     * Utility function to format allocation for display
     */
    formatAllocationSummary: function(allocation) {
        const summary = {};
        for (const [security, weight] of Object.entries(allocation)) {
            if (weight > 0.005) { // Show only positions > 0.5%
                summary[security] = `${(weight * 100).toFixed(1)}%`;
            }
        }
        return summary;
    },

    /**
     * Display comprehensive optimization results
     */
    displayOptimizationResults: function(results, containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            console.error('Container not found:', containerId);
            return;
        }
        
        const allocation = results.finalAllocation;
        const optimization = results.optimization;
        
        let html = `
            <div class="portfolio-optimization-results">
                <h3>Portfolio Optimization Results</h3>
                <div class="optimization-meta">
                    <strong>Framework:</strong> ${results.framework} | 
                    <strong>Version:</strong> ${results.version} | 
                    <strong>Execution:</strong> ${results.performance.executionTimeMs}ms
                </div>
                
                <div class="optimization-summary">
                    <h4>Optimization Summary</h4>
                    <div class="summary-grid">
                        <div>Selected Scenarios: <strong>${optimization.selectedScenarios}</strong></div>
                        <div>Cumulative Probability: <strong>${(optimization.cumulativeProbability*100).toFixed(1)}%</strong></div>
                        <div>Optimal α: <strong>${optimization.optimalAlpha}</strong></div>
                        <div>Max Regret: <strong>${(optimization.maxRegret*100).toFixed(2)}%</strong></div>
                        <div>Weighted Regret: <strong>${(optimization.weightedRegret*100).toFixed(2)}%</strong></div>
                        <div>Hedging Applied: <strong>${optimization.hedgingApplied ? 'Yes' : 'No'}</strong></div>
                    </div>
                </div>
                
                <div class="final-allocation">
                    <h4>Final Portfolio Allocation</h4>
                    <div class="allocation-grid">
        `;
        
        // Sort allocations by weight (descending)
        const sortedAllocations = Object.entries(allocation)
            .sort(([,a], [,b]) => b - a)
            .filter(([,weight]) => weight > 0.005); // Show only positions > 0.5%
        
        for (const [security, weight] of sortedAllocations) {
            const securityInfo = this.securities[security];
            const percentage = (weight * 100).toFixed(1);
            const barWidth = Math.max(2, weight * 300); // Visual bar
            
            html += `
                <div class="allocation-row">
                    <div class="security-info">
                        <strong>${security}</strong>
                        <small>${securityInfo?.name || 'Unknown'}</small>
                    </div>
                    <div class="allocation-bar">
                        <div class="bar-fill" style="width: ${barWidth}px; background-color: ${this.getSecurityColor(securityInfo?.type)}"></div>
                        <span class="percentage">${percentage}%</span>
                    </div>
                </div>
            `;
        }
        
        html += `
                    </div>
                </div>
                
                <div class="risk-metrics">
                    <h4>Risk Analysis</h4>
                    <div class="risk-grid">
                        <div>Equity Exposure: <strong>${(this.calculateSectorWeight(allocation, 'equity')*100).toFixed(1)}%</strong></div>
                        <div>Income Exposure: <strong>${(this.calculateSectorWeight(allocation, 'income')*100).toFixed(1)}%</strong></div>
                        <div>Alternatives: <strong>${(this.calculateSectorWeight(allocation, 'alternative')*100).toFixed(1)}%</strong></div>
                        <div>Cash: <strong>${(this.calculateSectorWeight(allocation, 'cash')*100).toFixed(1)}%</strong></div>
                    </div>
                </div>
            </div>
            
            <style>
                .portfolio-optimization-results { font-family: -apple-system, sans-serif; max-width: 800px; }
                .optimization-meta { color: #666; font-size: 0.9em; margin-bottom: 20px; }
                .summary-grid, .risk-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
                .allocation-grid { margin-top: 10px; }
                .allocation-row { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
                .security-info { flex: 1; }
                .security-info strong { display: block; }
                .security-info small { color: #666; font-size: 0.85em; }
                .allocation-bar { display: flex; align-items: center; gap: 10px; min-width: 150px; }
                .bar-fill { height: 20px; border-radius: 3px; }
                .percentage { font-weight: bold; min-width: 40px; text-align: right; }
            </style>
        `;
        
        container.innerHTML = html;
    },

    /**
     * Calculate sector weight for risk analysis
     */
    calculateSectorWeight: function(allocation, sectorType) {
        let weight = 0;
        for (const [security, alloc] of Object.entries(allocation)) {
            const securityInfo = this.securities[security];
            if (securityInfo && securityInfo.type === sectorType) {
                weight += alloc;
            }
        }
        return weight;
    },

    /**
     * Get color for security type
     */
    getSecurityColor: function(type) {
        const colors = {
            equity: '#007bff',      // Blue
            income: '#28a745',      // Green  
            alternative: '#ffc107', // Yellow
            cash: '#6c757d'         // Gray
        };
        return colors[type] || '#dee2e6';
    }
};

// Export for use in integration tests and tracker
if (typeof window !== 'undefined') {
    window.PortfolioOptimizer = PortfolioOptimizer;
}

console.log('PortfolioOptimizer v2.0 loaded - Regret Minimization Framework ready');

    </script>
</body>
</html>