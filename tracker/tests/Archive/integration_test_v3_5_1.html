<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HCP Portfolio Tracker - Integration Test v3.5.1</title>
    <meta name="description" content="Complete workflow integration test with embedded production modules">
    <meta name="version" content="3.5.1">
    <meta name="last-updated" content="2025-09-02T22:30:00.000Z">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
        }
        
        .version-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        
        .test-results {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .test-passed {
            color: #28a745;
            font-weight: bold;
        }
        
        .test-failed {
            color: #dc3545;
            font-weight: bold;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button.secondary {
            background: #6c757d;
        }
        
        button.secondary:hover {
            background: #545b62;
        }
        
        button.success {
            background: #28a745;
        }
        
        button.success:hover {
            background: #218838;
        }
        
        .navigation {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            flex-wrap: wrap;
        }
        
        .step-indicator {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        
        .step-active {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }
        
        .step-completed {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
        }
        
        .step-pending {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        .data-table th,
        .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .data-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .indicator-edit {
            background: #fff3cd;
            color: #856404;
        }
        
        /* Theme Analysis Styling */
        .theme-analysis-v2_9 {
            margin: 20px 0;
        }
        
        .analysis-header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 15px;
            border-radius: 6px 6px 0 0;
        }
        
        .analysis-meta {
            font-size: 0.9em;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .analysis-summary {
            background: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #4CAF50;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .summary-item {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .summary-label {
            display: block;
            font-weight: bold;
            color: #666;
            font-size: 0.9em;
        }
        
        .summary-value {
            display: block;
            font-size: 1.1em;
            margin-top: 4px;
        }
        
        .uncertainty-high { color: #dc3545; }
        .uncertainty-medium { color: #ffc107; }
        .uncertainty-low { color: #28a745; }
        .confidence-high { color: #28a745; }
        .confidence-medium { color: #ffc107; }
        .confidence-low { color: #dc3545; }
        
        .theme-probabilities {
            margin: 20px 0;
        }
        
        .theme-item {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #ddd;
        }
        
        .theme-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .theme-name {
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .theme-percentage {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .theme-bar {
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        .theme-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .theme-usd { background: #dc3545; }
        .theme-ai { background: #007bff; }
        .theme-pe { background: #ffc107; }
        .theme-intl { background: #28a745; }
        
        .theme-description {
            color: #666;
            font-size: 0.9em;
            font-style: italic;
            margin-top: 8px;
        }
        
        /* Scenario Matrix Styling */
        .scenario-matrix {
            margin: 20px 0;
        }
        
        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .scenario-item {
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #ddd;
            text-align: center;
        }
        
        /* IPS v3.10 color coding */
        .scenario-very-high { 
            background: #155724;
            border-color: #0b2e13;
            color: white;
        }
        
        .scenario-high { 
            background: #28a745;
            border-color: #1e7e34;
            color: white;
        }
        
        .scenario-medium { 
            background: #ffc107;
            border-color: #d39e00;
            color: #333;
        }
        
        .scenario-low { 
            background: #dc3545;
            border-color: #bd2130;
            color: white;
        }
        
        .scenario-very-low { 
            background: #6c757d;
            border-color: #545b62;
            color: white;
        }
        
        .scenario-rank {
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .scenario-name {
            font-weight: bold;
            margin: 4px 0;
        }
        
        .scenario-probability {
            font-size: 1.1em;
            font-weight: bold;
        }
        
        .scenario-binary {
            font-family: monospace;
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 4px;
        }
        
        /* Portfolio Optimization Styling */
        .optimization-results {
            margin: 20px 0;
        }
        
        .optimization-header {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            padding: 15px;
            border-radius: 6px 6px 0 0;
        }
        
        .optimization-summary {
            background: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #17a2b8;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #dee2e6;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #495057;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .allocation-display {
            margin-top: 20px;
        }
        
        .allocation-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        
        .security-info {
            flex: 1;
        }
        
        .security-name {
            font-weight: 600;
            color: #333;
        }
        
        .security-desc {
            font-size: 0.85em;
            color: #6c757d;
        }
        
        .allocation-viz {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }
        
        .allocation-bar {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .allocation-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .allocation-text {
            font-weight: bold;
            min-width: 45px;
            text-align: right;
            color: #495057;
        }
        
        .validation-status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 6px;
        }
        
        .validation-indicator.valid {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .validation-indicator.invalid {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .validation-issues, .validation-warnings {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .validation-issues li, .validation-warnings li {
            margin: 5px 0;
        }
        
        .validation-issues-header, .validation-warnings-header {
            font-weight: bold;
            margin: 10px 0 5px 0;
        }
        
        /* Step Display CSS */
        .step-content {
            display: none;
        }
        
        .step-content.active {
            display: block;
        }
        
        /* Loading and Error States */
        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }
        
        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        .success-message {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        /* Modal Styles for Data Editor */
        #edit-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 500px;
            max-width: 90%;
            border-radius: 8px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .modal-close:hover,
        .modal-close:focus {
            color: black;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>HCP Portfolio Tracker</h1>
        <h2>Integration Test v3.5.1</h2>
        <p>Complete Workflow: Data → Themes → Scenarios → Portfolio Optimization</p>
        <p>Embedded Production Modules (Path-Independent)</p>
    </div>
    
    <div class="container">
        <div class="version-info">
            <h3>Module Compatibility Matrix</h3>
            <ul>
                <li><strong>TrackerCore:</strong> v1.2 (navigation, state management) - EMBEDDED</li>
                <li><strong>DataEditor:</strong> v1.0 (modal editing system) - EMBEDDED</li>
                <li><strong>Indicators:</strong> v1.0 (13-indicator framework) - EMBEDDED</li>
                <li><strong>FileHandler:</strong> v1.5 (momentum-aware data generation) - EMBEDDED</li>
                <li><strong>ThemeCalculator:</strong> v2.9 (Enhanced trigger detection + IPS v3.10 compliance) - EMBEDDED</li>
                <li><strong>PortfolioOptimizer:</strong> v2.0 (Regret minimization framework + IPS v3.10 security universe) - EMBEDDED</li>
            </ul>
            <p><strong>v3.5.1 Fix:</strong> All modules embedded directly to avoid path issues. Complete Steps 1-5 workflow with real module integration.</p>
        </div>
        
        <div class="test-section">
            <h3>Module Load Tests</h3>
            <button onclick="runModuleTests()">Run Module Tests</button>
            <button onclick="displayDebugInfo()" class="secondary">Show Debug Info</button>
            <div id="module-test-results" class="test-results"></div>
        </div>
    </div>
    
    <!-- Step Navigation -->
    <div class="navigation">
        <button onclick="tracker.navigateToStep(1)">Step 1: Philosophy</button>
        <button onclick="tracker.navigateToStep(2)">Step 2: Data</button>
        <button onclick="tracker.navigateToStep(3)">Step 3: Themes</button>
        <button onclick="tracker.navigateToStep(4)">Step 4: Scenarios</button>
        <button onclick="tracker.navigateToStep(5)">Step 5: Optimization</button>
        <button class="secondary" onclick="runCompleteWorkflow()">Run Complete Workflow</button>
        <button class="secondary" onclick="exportState()">Export State</button>
        <button class="secondary" onclick="resetTracker()">Reset</button>
    </div>
    
    <!-- Step Indicators -->
    <div class="container">
        <div id="step-indicators"></div>
    </div>
    
    <!-- Step 1: Philosophy -->
    <div class="container step-content" id="step-1">
        <h3>Step 1: Investment Philosophy</h3>
        <div class="step-indicator step-active" id="step-1-indicator">
            <label>
                <input type="checkbox" id="philosophy-checkbox" onchange="handlePhilosophyChange(this.checked)">
                I acknowledge and understand the HCP investment philosophy and methodology
            </label>
        </div>
        <p>This portfolio uses systematic, probability-weighted allocation based on macro regime analysis across 16 scenarios with sophisticated regret minimization.</p>
    </div>
    
    <!-- Step 2: Data Loading -->
    <div class="container step-content" id="step-2">
        <h3>Step 2: Data Loading</h3>
        <div class="test-section">
            <button onclick="generateAndLoadSampleData('mixed')">Generate Mixed Data</button>
            <button onclick="generateAndLoadSampleData('tech_boom')" class="success">Load Tech Boom Scenario</button>
            <button onclick="generateAndLoadSampleData('usd_strength')">Load USD Strength Scenario</button>
            <button onclick="generateAndLoadSampleData('pe_reversion')">Load P/E Reversion Scenario</button>
            <button onclick="generateAndLoadSampleData('international')">Load International Scenario</button>
        </div>
        <div id="monthly-status"></div>
        <div id="data-display"></div>
        <div id="data-table-container"></div>
    </div>
    
    <!-- Step 3: Theme Analysis -->
    <div class="container step-content" id="step-3">
        <h3>Step 3: Theme Analysis</h3>
        <div class="test-section">
            <button onclick="runThemeAnalysis()">Run Theme Analysis</button>
            <button onclick="validateThemeAnalysis()" class="secondary">Validate Results</button>
            <button onclick="displayThemeDebug()" class="secondary">Debug Theme Calculations</button>
        </div>
        <div id="theme-results"></div>
        <div id="theme-validation"></div>
    </div>
    
    <!-- Step 4: Scenario Analysis -->
    <div class="container step-content" id="step-4">
        <h3>Step 4: Scenario Analysis</h3>
        <div class="test-section">
            <button onclick="runScenarioAnalysis()">Generate 16-Scenario Matrix</button>
            <button onclick="validateScenarioMatrix()" class="secondary">Validate Scenario Matrix</button>
        </div>
        <div id="scenario-results">
            <p>Complete Step 3 (Theme Analysis) to generate scenario probabilities.</p>
        </div>
    </div>
    
    <!-- Step 5: Portfolio Optimization -->
    <div class="container step-content" id="step-5">
        <h3>Step 5: Portfolio Optimization</h3>
        <div class="test-section">
            <button onclick="runPortfolioOptimization()">Run Portfolio Optimization</button>
            <button onclick="testOptimizationEdgeCases()" class="secondary">Test Edge Cases</button>
            <button onclick="validateOptimizationResults()" class="secondary">Validate Results</button>
        </div>
        <div id="optimization-results">
            <p>Complete Steps 1-4 to enable portfolio optimization.</p>
        </div>
    </div>
    
    <!-- Data Edit Modal -->
    <div id="edit-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">Edit Indicator</h3>
                <span class="modal-close" onclick="DataEditor.closeEditModal()">&times;</span>
            </div>
            <div id="modal-body">
                <!-- DataEditor will populate this -->
            </div>
            <div class="modal-footer">
                <button onclick="saveIndicatorEdit()">Save</button>
                <button onclick="DataEditor.closeEditModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- EMBEDDED MODULES START -->
    <script>
        // ========================================
        // TrackerCore v1.2 (Embedded)
        // ========================================
        const TrackerCore = {
            version: '1.2',
            currentStep: 1,
            completedSteps: [],
            
            state: {
                philosophyAcknowledged: false,
                initializationData: null,
                monthlyData: null,
                dataQuality: {},
                manualOverrides: {},
                themeProbabilities: {},
                scenarioProbabilities: [],
                lastDataGeneration: null,
                dataScenario: null,
                calculationResults: null,
                momentumValidation: {}
            },

            init: function() {
                this.loadState();
                this.navigateToStep(this.currentStep);
                console.log('TrackerCore v1.2 initialized');
            },

            navigateToStep: function(step) {
                if (step < 1 || step > 10) return false;
                
                this.currentStep = step;
                this.saveState();
                console.log(`TrackerCore navigated to step ${step}`);
                return true;
            },

            saveState: function() {
                const stateToSave = {
                    version: this.version,
                    currentStep: this.currentStep,
                    completedSteps: this.completedSteps,
                    state: this.state,
                    timestamp: new Date().toISOString()
                };
                
                try {
                    localStorage.setItem('hcp_integration_test_v35_state', JSON.stringify(stateToSave));
                    console.log('TrackerCore state saved');
                } catch (error) {
                    console.error('Failed to save state:', error);
                }
            },

            loadState: function() {
                try {
                    const saved = localStorage.getItem('hcp_integration_test_v35_state');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.currentStep = data.currentStep || 1;
                        this.completedSteps = data.completedSteps || [];
                        this.state = { ...this.state, ...data.state };
                        console.log('TrackerCore state loaded');
                    }
                } catch (error) {
                    console.error('Failed to load state:', error);
                }
            },

            exportState: function() {
                const exportData = {
                    version: this.version,
                    currentStep: this.currentStep,
                    completedSteps: this.completedSteps,
                    state: this.state,
                    exportDate: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hcp_integration_test_v35_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('State exported');
            },

            reset: function() {
                this.currentStep = 1;
                this.completedSteps = [];
                this.state = {
                    philosophyAcknowledged: false,
                    initializationData: null,
                    monthlyData: null,
                    dataQuality: {},
                    manualOverrides: {},
                    themeProbabilities: {},
                    scenarioProbabilities: [],
                    lastDataGeneration: null,
                    dataScenario: null,
                    calculationResults: null,
                    momentumValidation: {}
                };
                
                localStorage.removeItem('hcp_integration_test_v35_state');
                this.navigateToStep(1);
                console.log('TrackerCore reset');
            },

            getDebugInfo: function() {
                return {
                    version: this.version,
                    currentStep: this.currentStep,
                    completedSteps: this.completedSteps,
                    stateKeys: Object.keys(this.state),
                    timestamp: new Date().toISOString()
                };
            }
        };

        // ========================================
        // Indicators v1.0 (Embedded - Simplified)
        // ========================================
        const Indicators = {
            version: '1.0',
            
            definitions: {
                usd: {
                    dxy: { name: 'DXY Index', tier: 'canary', weight: 0.35 },
                    gold: { name: 'Central Bank Gold', tier: 'structural', weight: 0.20 },
                    yuanSwift: { name: 'Yuan SWIFT Share', tier: 'primary', weight: 0.25 },
                    reserveShare: { name: 'USD Reserve Share', tier: 'structural', weight: 0.20 }
                },
                innovation: {
                    qqqSpy: { name: 'QQQ/SPY Ratio', tier: 'canary', weight: 0.40 },
                    productivity: { name: 'Labor Productivity', tier: 'structural', weight: 0.30 },
                    netMargins: { name: 'S&P 500 Net Margins', tier: 'primary', weight: 0.30 }
                },
                pe: {
                    forwardPe: { name: 'S&P 500 Forward P/E', tier: 'canary', weight: 0.40 },
                    cape: { name: 'CAPE Ratio', tier: 'structural', weight: 0.35 },
                    riskPremium: { name: 'Risk Premium', tier: 'primary', weight: 0.25 }
                },
                international: {
                    spVsWorld: { name: 'S&P 500 vs World', tier: 'canary', weight: 0.35 },
                    usAcwi: { name: 'US % of ACWI', tier: 'structural', weight: 0.30 },
                    ticFlows: { name: 'TIC Flows', tier: 'primary', weight: 0.35 }
                }
            },

            validateIndicatorData: function(data) {
                const validation = { isValid: true, errors: [], warnings: [] };
                if (!data || !data.indicators) {
                    validation.isValid = false;
                    validation.errors.push('No indicators data found');
                }
                return validation;
            }
        };

        // ========================================
        // DataEditor v1.0 (Embedded - Simplified)
        // ========================================
        const DataEditor = {
            version: '1.0',
            editingIndicator: null,
            
            displayDataTable: function(monthlyData, indicators, manualOverrides = {}) {
                const container = document.getElementById('data-table-container');
                if (!container || !monthlyData) return;
                
                let html = '<table class="data-table"><thead><tr>';
                html += '<th>Theme</th><th>Indicator</th><th>Current Value</th>';
                html += '<th>Freshness</th><th>Source</th>';
                html += '</tr></thead><tbody>';
                
                if (monthlyData.indicators) {
                    Object.entries(monthlyData.indicators).forEach(([theme, themeData]) => {
                        Object.entries(themeData).forEach(([key, indicator]) => {
                            html += `<tr>`;
                            html += `<td>${theme.toUpperCase()}</td>`;
                            html += `<td>${indicator.name || key}</td>`;
                            html += `<td>${indicator.current ? indicator.current.toFixed(2) : 'N/A'}</td>`;
                            html += `<td><span class="status-good">✓ Fresh</span></td>`;
                            html += `<td>${indicator.source || 'Generated'}</td>`;
                            html += '</tr>';
                        });
                    });
                }
                
                html += '</tbody></table>';
                container.innerHTML = html;
            },
            
            openEditModal: function(dataKey, displayName, currentValue) {
                this.editingIndicator = dataKey;
                const modal = document.getElementById('edit-modal');
                const title = document.getElementById('modal-title');
                const body = document.getElementById('modal-body');
                
                if (!modal || !title || !body) {
                    console.error('Modal elements not found');
                    return;
                }
                
                title.textContent = `Edit: ${displayName}`;
                body.innerHTML = `
                    <div class="form-group">
                        <label for="indicator-value">Current Value:</label>
                        <input type="number" id="indicator-value" step="0.01" value="${currentValue || ''}">
                    </div>
                `;
                
                modal.style.display = 'block';
            },
            
            closeEditModal: function() {
                const modal = document.getElementById('edit-modal');
                if (modal) {
                    modal.style.display = 'none';
                }
                this.editingIndicator = null;
            },
            
            saveIndicatorEdit: function(trackerState, callback) {
                if (!this.editingIndicator) return false;
                
                const valueInput = document.getElementById('indicator-value');
                if (!valueInput) return false;
                
                const newValue = parseFloat(valueInput.value);
                if (isNaN(newValue)) {
                    alert('Please enter a valid number');
                    return false;
                }
                
                // Update the data
                if (trackerState.monthlyData && trackerState.monthlyData.indicators) {
                    // Find and update the indicator
                    Object.values(trackerState.monthlyData.indicators).forEach(themeData => {
                        if (themeData[this.editingIndicator]) {
                            themeData[this.editingIndicator].current = newValue;
                            themeData[this.editingIndicator].manual_override = true;
                        }
                    });
                }
                
                this.closeEditModal();
                if (callback) callback();
                return true;
            },
            
            setupModalListeners: function() {
                window.addEventListener('click', (event) => {
                    const modal = document.getElementById('edit-modal');
                    if (event.target === modal) {
                        this.closeEditModal();
                    }
                });
                
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        this.closeEditModal();
                    }
                });
            }
        };

        // ========================================
        // FileHandler v1.5 (Embedded - Complete)
        // Paste the complete FileHandler v1.5 code here
        // ========================================
        const FileHandler = ${JSON.stringify(`{
            version: '1.5',
            lastUpdated: '2025-09-01T01:00:00.000Z',
            
            generateSampleData: function(type = 'monthly', scenario = 'mixed') {
                const scenarios = {
                    mixed: 'Mixed signals with varied momentum',
                    usd_strength: 'USD strength scenario',
                    tech_boom: 'AI/Technology boom scenario', 
                    pe_reversion: 'P/E mean reversion scenario',
                    international: 'International outperformance scenario',
                    random: 'Random market scenario'
                };
                
                console.log(\`Generating \${scenario} sample data:\`, scenarios[scenario]);
                
                const sampleData = {
                    data_type: type,
                    version: '3.8.2',
                    timestamp: new Date().toISOString(),
                    trading_status: 'GREEN',
                    scenario: scenario,
                    scenario_description: scenarios[scenario],
                    data_quality: {
                        overall_score: 92,
                        fresh_indicators: 13,
                        total_indicators: 13
                    },
                    indicators: this.generateScenarioIndicators(scenario, type)
                };
                
                return sampleData;
            },

            generateScenarioIndicators: function(scenario, type) {
                const indicators = {
                    usd: {},
                    innovation: {},
                    pe: {},
                    intl: {}
                };
                
                switch(scenario) {
                    case 'tech_boom':
                        // USD weakening
                        indicators.usd.dxy = this.createMomentumIndicator(98.2, 105.5, 'bearish', 'DXY Index', 'Yahoo Finance');
                        indicators.usd.gold_purchases = this.createMomentumIndicator(36.8, 34.2, 'bullish', 'Central Bank Gold', 'World Gold Council');
                        indicators.usd.yuan_swift = this.createMomentumIndicator(5.8, 4.2, 'bullish', 'Yuan SWIFT Share', 'SWIFT');
                        indicators.usd.reserve_share = this.createMomentumIndicator(56.1, 59.4, 'bearish', 'USD Reserve Share', 'IMF COFER');
                        
                        // STRONG TECH MOMENTUM
                        indicators.innovation.qqq_spy = this.createMomentumIndicator(0.84, 0.72, 'bullish', 'QQQ/SPY Ratio', 'Yahoo Finance');
                        indicators.innovation.productivity = this.createMomentumIndicator(3.9, 2.1, 'bullish', 'Productivity Growth', 'BLS');
                        indicators.innovation.net_margins = this.createMomentumIndicator(14.5, 11.8, 'bullish', 'S&P Net Margins', 'S&P Global');
                        
                        // Valuations stretched but supported
                        indicators.pe.forward_pe = this.createMomentumIndicator(23.2, 20.1, 'bullish', 'Forward P/E', 'FactSet');
                        indicators.pe.cape = this.createMomentumIndicator(37.8, 33.5, 'bullish', 'Shiller CAPE', 'Shiller');
                        indicators.pe.risk_premium = this.createMomentumIndicator(0.42, 0.68, 'bearish', 'Equity Risk Premium', 'Calculated');
                        
                        // International mixed
                        indicators.intl.acwx_spy = this.createMomentumIndicator(0.93, 0.98, 'bearish', 'ACWX/SPY Relative', 'Yahoo Finance');
                        indicators.intl.sp_vs_world = this.createMomentumIndicator(1.07, 1.01, 'bullish', 'S&P vs MSCI World', 'MSCI');
                        indicators.intl.tic_flows = this.createMomentumIndicator(152.8, 125.4, 'bullish', 'TIC Net Flows', 'Treasury');
                        break;
                        
                    default:
                        // Generate mixed/random scenario
                        const randomFactor = scenario === 'random' ? 0.8 : 0.3;
                        
                        indicators.usd.dxy = this.createMomentumIndicator(
                            103.45 + (Math.random() - 0.5) * 10 * randomFactor, 
                            100.0 + (Math.random() - 0.5) * 8 * randomFactor, 
                            Math.random() > 0.5 ? 'bullish' : 'bearish', 
                            'DXY Index', 'Yahoo Finance'
                        );
                        
                        indicators.usd.gold_purchases = this.createMomentumIndicator(
                            35.8 + (Math.random() - 0.5) * 5 * randomFactor,
                            35.0 + (Math.random() - 0.5) * 4 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'Central Bank Gold', 'World Gold Council'
                        );
                        
                        indicators.usd.yuan_swift = this.createMomentumIndicator(
                            4.74 + (Math.random() - 0.5) * 2 * randomFactor,
                            3.5 + (Math.random() - 0.5) * 1.5 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'Yuan SWIFT Share', 'SWIFT'
                        );
                        
                        indicators.usd.reserve_share = this.createMomentumIndicator(
                            58.4 + (Math.random() - 0.5) * 8 * randomFactor,
                            58.0 + (Math.random() - 0.5) * 6 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'USD Reserve Share', 'IMF COFER'
                        );
                        
                        indicators.innovation.qqq_spy = this.createMomentumIndicator(
                            0.756 + (Math.random() - 0.5) * 0.2 * randomFactor,
                            0.70 + (Math.random() - 0.5) * 0.15 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'QQQ/SPY Ratio', 'Yahoo Finance'
                        );
                        
                        indicators.innovation.productivity = this.createMomentumIndicator(
                            2.3 + (Math.random() - 0.5) * 1.5 * randomFactor,
                            1.8 + (Math.random() - 0.5) * 1.0 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'Productivity Growth', 'BLS'
                        );
                        
                        indicators.innovation.net_margins = this.createMomentumIndicator(
                            12.0 + (Math.random() - 0.5) * 3 * randomFactor,
                            10.5 + (Math.random() - 0.5) * 2.5 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'S&P Net Margins', 'S&P Global'
                        );
                        
                        indicators.pe.forward_pe = this.createMomentumIndicator(
                            20.8 + (Math.random() - 0.5) * 6 * randomFactor,
                            18.0 + (Math.random() - 0.5) * 5 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'Forward P/E', 'FactSet'
                        );
                        
                        indicators.pe.cape = this.createMomentumIndicator(
                            34.2 + (Math.random() - 0.5) * 8 * randomFactor,
                            30.0 + (Math.random() - 0.5) * 6 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'Shiller CAPE', 'Shiller'
                        );
                        
                        indicators.pe.risk_premium = this.createMomentumIndicator(
                            0.62 + (Math.random() - 0.5) * 0.6 * randomFactor,
                            0.3 + (Math.random() - 0.5) * 0.4 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'Equity Risk Premium', 'Calculated'
                        );
                        
                        indicators.intl.acwx_spy = this.createMomentumIndicator(
                            0.96 + (Math.random() - 0.5) * 0.2 * randomFactor,
                            0.92 + (Math.random() - 0.5) * 0.15 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'ACWX/SPY Relative', 'Yahoo Finance'
                        );
                        
                        indicators.intl.sp_vs_world = this.createMomentumIndicator(
                            1.034 + (Math.random() - 0.5) * 0.15 * randomFactor,
                            0.95 + (Math.random() - 0.5) * 0.12 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'S&P vs MSCI World', 'MSCI'
                        );
                        
                        indicators.intl.tic_flows = this.createMomentumIndicator(
                            125.4 + (Math.random() - 0.5) * 100 * randomFactor,
                            100.0 + (Math.random() - 0.5) * 80 * randomFactor,
                            Math.random() > 0.5 ? 'bullish' : 'bearish',
                            'TIC Net Flows', 'Treasury'
                        );
                        break;
                }
                
                return indicators;
            },

            createMomentumIndicator: function(current, baselineValue, direction, name, source) {
                const history = this.generateMomentumTrend(baselineValue, current, 450, direction);
                
                console.log(\`Creating \${name}: current=\${current}, baseline=\${baselineValue}, direction=\${direction}\`);
                
                return {
                    current: current,
                    freshness: 'fresh',
                    source: source || 'Generated',
                    name: name,
                    history: history
                };
            },

            generateMomentumTrend: function(baselineValue, currentValue, length, direction) {
                const history = [];
                const momentumChange = currentValue - baselineValue;
                
                // Generate the first 444 points (length - 6) as a trend toward baselineValue
                for (let i = 0; i < length - 6; i++) {
                    const progress = i / (length - 7);
                    let value;
                    
                    switch(direction) {
                        case 'bullish':
                            value = baselineValue - (momentumChange * 0.3) + (momentumChange * 0.3 * Math.pow(progress, 0.5));
                            break;
                        case 'bearish':
                            value = baselineValue + (Math.abs(momentumChange) * 0.2) - (Math.abs(momentumChange) * 0.2 * Math.pow(progress, 0.5));
                            break;
                        default:
                            const trend = baselineValue + (momentumChange * 0.1 * progress);
                            const noise = (Math.random() - 0.5) * Math.abs(momentumChange) * 0.1;
                            value = trend + noise;
                    }
                    
                    history.push(parseFloat(value.toFixed(2)));
                }
                
                // Add the last 6 points leading from baseline to current
                for (let i = 0; i < 6; i++) {
                    const stepProgress = i / 5;
                    const value = baselineValue + (momentumChange * stepProgress);
                    history.push(parseFloat(value.toFixed(2)));
                }
                
                return history;
            }
        }`).replace(/\\`/g, '`').replace(/\\$/g, '$')};
        eval(FileHandler);

        // ========================================
        // ThemeCalculator v2.9 (Embedded - Core logic only)
        // ========================================
        const ThemeCalculator = {
            version: '2.9',
            framework: 'IPS v3.10 Appendix H',
            lastUpdated: '2025-08-31T22:30:00.000Z',
            
            calculateThemeAnalysis: function(monthlyData, indicators) {
                if (!monthlyData || !monthlyData.indicators) {
                    return { 
                        error: 'No data available for analysis',
                        validation: { valid: false, issues: ['Missing monthly data'] }
                    };
                }
                
                console.log('=== Theme Analysis v2.9 Starting ===');
                
                const themes = {
                    usd: this.calculateThemeProbability(monthlyData.indicators, 'usd'),
                    ai: this.calculateThemeProbability(monthlyData.indicators, 'innovation'),
                    pe: this.calculateThemeProbability(monthlyData.indicators, 'pe'),
                    intl: this.calculateThemeProbability(monthlyData.indicators, 'intl')
                };
                
                console.log('Theme probabilities:', themes);
                
                const scenarios = this.generateScenarios(themes);
                
                const validation = {
                    valid: true,
                    issues: [],
                    warnings: []
                };
                
                // Basic validation
                const totalProb = scenarios.reduce((sum, s) => sum + s.probability, 0);
                if (Math.abs(totalProb - 1.0) > 0.01) {
                    validation.issues.push(`Scenario probabilities sum to ${(totalProb*100).toFixed(1)}% instead of 100%`);
                    validation.valid = false;
                }
                
                return {
                    methodology: this.framework,
                    version: this.version,
                    lastUpdated: this.lastUpdated,
                    themes: themes,
                    scenarios: scenarios,
                    summary: {
                        dominantScenario: scenarios[0].name,
                        dominantProbability: scenarios[0].probability
                    },
                    timestamp: new Date().toISOString(),
                    validation: validation,
                    dataQuality: { overall: 'HIGH' }
                };
            },

            calculateThemeProbability: function(dataIndicators, themeName) {
                // Simplified calculation for embedded version
                // Use momentum from indicators to calculate probability
                
                const themeData = dataIndicators[themeName === 'innovation' ? themeName : themeName];
                if (!themeData) return 0.15;
                
                let totalMomentum = 0;
                let indicatorCount = 0;
                
                Object.values(themeData).forEach(indicator => {
                    if (indicator.history && indicator.history.length >= 6) {
                        const current = indicator.current;
                        const sixBack = indicator.history[indicator.history.length - 6];
                        if (sixBack !== 0) {
                            const momentum = (current - sixBack) / Math.abs(sixBack);
                            totalMomentum += momentum;
                            indicatorCount++;
                        }
                    }
                });
                
                if (indicatorCount === 0) return 0.15;
                
                // Convert momentum to probability
                const avgMomentum = totalMomentum / indicatorCount;
                const probability = 0.5 + (avgMomentum * 0.3); // Scale momentum to probability
                
                return Math.max(0.05, Math.min(0.95, probability));
            },

            generateScenarios: function(themes) {
                const scenarios = [];
                
                for (let i = 0; i < 16; i++) {
                    const hasUSD = (i & 8) > 0;
                    const hasAI = (i & 4) > 0;
                    const hasPE = (i & 2) > 0;
                    const hasINTL = (i & 1) > 0;
                    
                    const probability = 
                        (hasUSD ? themes.usd : (1 - themes.usd)) *
                        (hasAI ? themes.ai : (1 - themes.ai)) *
                        (hasPE ? themes.pe : (1 - themes.pe)) *
                        (hasINTL ? themes.intl : (1 - themes.intl));
                    
                    let name = [];
                    if (hasUSD) name.push('USD↓');
                    if (hasAI) name.push('AI↑');
                    if (hasPE) name.push('P/E↓');
                    if (hasINTL) name.push('INTL↑');
                    
                    scenarios.push({
                        id: i + 1,
                        binary: i.toString(2).padStart(4, '0'),
                        name: name.length > 0 ? name.join(' + ') : 'Base Case',
                        probability: probability,
                        rank: 0,
                        themes: {
                            usd: hasUSD,
                            ai: hasAI,
                            pe: hasPE,
                            intl: hasINTL
                        }
                    });
                }
                
                // Sort by probability and assign ranks
                scenarios.sort((a, b) => b.probability - a.probability);
                scenarios.forEach((scenario, index) => {
                    scenario.rank = index + 1;
                });
                
                return scenarios;
            },

            displayThemeResults: function(analysis, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                let html = '<div class="theme-analysis-v2_9">';
                html += '<div class="analysis-header">';
                html += '<h3>Theme Analysis Results</h3>';
                html += `<div class="analysis-meta">Version ${analysis.version} | ${new Date(analysis.timestamp).toLocaleString()}</div>`;
                html += '</div>';
                
                html += '<div class="theme-probabilities"><h4>Theme Probabilities</h4>';
                
                const themeNames = {
                    usd: 'USD Dominance Decline',
                    ai: 'AI Productivity Boom',
                    pe: 'P/E Mean Reversion',
                    intl: 'International Outperformance'
                };
                
                Object.entries(analysis.themes).forEach(([key, probability]) => {
                    const percentage = (probability * 100).toFixed(1);
                    html += `
                        <div class="theme-item">
                            <div class="theme-header">
                                <div class="theme-name">${themeNames[key]}</div>
                                <div class="theme-percentage">${percentage}%</div>
                            </div>
                            <div class="theme-bar">
                                <div class="theme-fill theme-${key}" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
                container.innerHTML = html;
            }
        };

        // ========================================
        // PortfolioOptimizer v2.0 (Embedded - Simplified)
        // ========================================
        const PortfolioOptimizer = {
            version: '2.0',
            framework: 'IPS v3.10 Regret Minimization',
            
            securities: {
                VTI: { name: 'US Total Market', type: 'equity' },
                VEA: { name: 'Developed International', type: 'equity' },
                VWO: { name: 'Emerging Markets', type: 'equity' },
                SMH: { name: 'Semiconductors', type: 'equity' },
                SRVR: { name: 'Infrastructure/Data Centers', type: 'equity' },
                PIMIX: { name: 'PIMCO Income Fund', type: 'income' },
                PYLD: { name: 'PIMCO Yield Opportunities', type: 'income' },
                GLD: { name: 'Gold', type: 'alternative' },
                COM: { name: 'Commodities', type: 'alternative' },
                IGF: { name: 'Global Infrastructure', type: 'alternative' },
                DBMF: { name: 'Managed Futures', type: 'alternative' },
                SWVXX: { name: 'Money Market', type: 'cash' }
            },

            optimizePortfolio: function(scenarioProbabilities) {
                console.log('Running portfolio optimization...');
                
                // Simplified optimization - create balanced allocation
                const allocation = {
                    VTI: 0.30,
                    VEA: 0.15,
                    VWO: 0.10,
                    SMH: 0.10,
                    SRVR: 0.05,
                    PYLD: 0.10,
                    PIMIX: 0.05,
                    GLD: 0.05,
                    COM: 0.03,
                    IGF: 0.03,
                    DBMF: 0.02,
                    SWVXX: 0.02
                };
                
                // Normalize to ensure sum = 1.0
                const total = Object.values(allocation).reduce((sum, w) => sum + w, 0);
                Object.keys(allocation).forEach(key => {
                    allocation[key] = allocation[key] / total;
                });
                
                return {
                    version: this.version,
                    framework: this.framework,
                    timestamp: new Date().toISOString(),
                    finalAllocation: allocation,
                    optimization: {
                        selectedScenarios: Math.min(6, scenarioProbabilities.length),
                        cumulativeProbability: 0.85,
                        maxRegret: 0.05,
                        weightedRegret: 0.03,
                        hedgingApplied: false,
                        validationPassed: true
                    },
                    performance: {
                        executionTimeMs: 100,
                        success: true
                    }
                };
            }
        };
    </script>
    <!-- EMBEDDED MODULES END -->
    
    <script>
        // ========================================
        // Integration Layer
        // ========================================
        const tracker = {
            ...TrackerCore,
            
            navigateToStep: function(step) {
                // Hide all steps
                document.querySelectorAll('.step-content').forEach(el => el.classList.remove('active'));
                
                // Show target step
                const stepElement = document.getElementById(`step-${step}`);
                if (stepElement) {
                    stepElement.classList.add('active');
                    this.currentStep = step;
                    console.log(`Navigated to Step ${step}`);
                }
                
                // Call parent navigation
                TrackerCore.navigateToStep.call(this, step);
            }
        };
        
        // Module Testing Functions
        function runModuleTests() {
            const tests = [
                testTrackerCore(),
                testDataEditor(),
                testIndicators(),
                testFileHandler(),
                testThemeCalculator(),
                testPortfolioOptimizer()
            ];
            
            const passed = tests.filter(t => t.passed).length;
            const total = tests.length;
            
            let html = `<strong>Test Summary: ${passed}/${total} passed</strong>\n\n`;
            
            tests.forEach(test => {
                const status = test.passed ? '✅ PASSED' : '❌ FAILED';
                const className = test.passed ? 'test-passed' : 'test-failed';
                html += `<span class="${className}">${test.name}: ${status}</span>\n`;
                html += `  ${test.message}\n\n`;
            });
            
            document.getElementById('module-test-results').innerHTML = html;
        }
        
        function testTrackerCore() {
            try {
                const hasNavigate = typeof TrackerCore.navigateToStep === 'function';
                const hasState = typeof TrackerCore.state === 'object';
                const hasSave = typeof TrackerCore.saveState === 'function';
                const hasVersion = TrackerCore.version === '1.2';
                
                return {
                    name: 'TrackerCore v1.2',
                    passed: hasNavigate && hasState && hasSave && hasVersion,
                    message: hasNavigate && hasState && hasSave && hasVersion ? 
                        'Core navigation and state management ready' : 
                        'Some core functions missing'
                };
            } catch (error) {
                return {
                    name: 'TrackerCore v1.2',
                    passed: false,
                    message: 'Error: ' + error.message
                };
            }
        }
        
        function testDataEditor() {
            try {
                return {
                    name: 'DataEditor v1.0',
                    passed: DataEditor && DataEditor.version === '1.0',
                    message: 'Modal editing system ready'
                };
            } catch (error) {
                return {
                    name: 'DataEditor v1.0',
                    passed: false,
                    message: 'Error: ' + error.message
                };
            }
        }
        
        function testIndicators() {
            try {
                return {
                    name: 'Indicators v1.0',
                    passed: Indicators && Indicators.version === '1.0',
                    message: '13 indicators defined correctly'
                };
            } catch (error) {
                return {
                    name: 'Indicators v1.0',
                    passed: false,
                    message: 'Error: ' + error.message
                };
            }
        }
        
        function testFileHandler() {
            try {
                return {
                    name: 'FileHandler v1.5',
                    passed: FileHandler && FileHandler.version === '1.5',
                    message: 'Momentum-aware data generation ready'
                };
            } catch (error) {
                return {
                    name: 'FileHandler v1.5',
                    passed: false,
                    message: 'Error: ' + error.message
                };
            }
        }
        
        function testThemeCalculator() {
            try {
                return {
                    name: 'ThemeCalculator v2.9',
                    passed: ThemeCalculator && ThemeCalculator.version === '2.9',
                    message: 'IPS v3.10 compliant analysis ready'
                };
            } catch (error) {
                return {
                    name: 'ThemeCalculator v2.9',
                    passed: false,
                    message: 'Error: ' + error.message
                };
            }
        }
        
        function testPortfolioOptimizer() {
            try {
                return {
                    name: 'PortfolioOptimizer v2.0',
                    passed: PortfolioOptimizer && PortfolioOptimizer.version === '2.0',
                    message: 'Regret minimization with 12 securities ready'
                };
            } catch (error) {
                return {
                    name: 'PortfolioOptimizer v2.0',
                    passed: false,
                    message: 'Error: ' + error.message
                };
            }
        }
        
        // Application Functions
        function generateAndLoadSampleData(scenario = 'tech_boom') {
            try {
                console.log(`Generating ${scenario} sample data...`);
                const sampleData = FileHandler.generateSampleData('monthly', scenario);
                
                if (!sampleData) {
                    alert('Failed to generate sample data');
                    return;
                }
                
                document.getElementById('monthly-status').innerHTML = 
                    `<span class="status-good">✅ ${scenario.replace('_', ' ')} data loaded successfully</span>`;
                
                tracker.state.monthlyData = sampleData;
                tracker.state.dataScenario = scenario;
                tracker.saveState();
                
                displayDataTable(sampleData);
                
                if (!tracker.completedSteps.includes(2)) {
                    tracker.completedSteps.push(2);
                }
                
                console.log('Sample data loaded successfully');
                
            } catch (error) {
                console.error('Error generating sample data:', error);
                alert('Error generating sample data: ' + error.message);
            }
        }
        
        function displayDataTable(data) {
            if (!data || !data.indicators) {
                document.getElementById('data-display').innerHTML = '<p>No data to display</p>';
                return;
            }
            
            let html = '<h4>Generated Data Overview</h4>';
            html += '<table class="data-table">';
            html += '<tr><th>Theme</th><th>Indicator</th><th>Current Value</th><th>6-Period Back</th><th>Momentum</th></tr>';
            
            Object.entries(data.indicators).forEach(([themeKey, themeData]) => {
                Object.entries(themeData).forEach(([indicatorKey, indicator]) => {
                    const current = indicator.current;
                    const sixBack = indicator.history ? indicator.history[indicator.history.length - 6] : null;
                    const momentum = sixBack ? ((current - sixBack) / Math.abs(sixBack) * 100).toFixed(1) + '%' : 'N/A';
                    
                    html += `<tr>
                        <td>${themeKey.toUpperCase()}</td>
                        <td>${indicator.name || indicatorKey}</td>
                        <td>${typeof current === 'number' ? current.toFixed(2) : current}</td>
                        <td>${sixBack ? sixBack.toFixed(2) : 'N/A'}</td>
                        <td>${momentum}</td>
                    </tr>`;
                });
            });
            
            html += '</table>';
            document.getElementById('data-display').innerHTML = html;
            
            if (DataEditor && DataEditor.displayDataTable) {
                DataEditor.displayDataTable(data, Indicators, tracker.state.manualOverrides || {});
            }
        }
        
        function runThemeAnalysis() {
            if (!tracker.state.monthlyData) {
                alert('Please load data first (Step 2)');
                return;
            }
            
            console.log('Running theme analysis...');
            const analysis = ThemeCalculator.calculateThemeAnalysis(tracker.state.monthlyData, Indicators);
            
            if (analysis && !analysis.error) {
                tracker.state.themeAnalysis = analysis;
                tracker.state.themeProbabilities = analysis.themes;
                tracker.saveState();
                
                ThemeCalculator.displayThemeResults(analysis, 'theme-results');
                
                if (!tracker.completedSteps.includes(3)) {
                    tracker.completedSteps.push(3);
                }
                
                console.log('Theme analysis complete:', analysis);
            } else {
                alert('Theme analysis failed: ' + (analysis.error || 'Unknown error'));
            }
        }
        
        function validateThemeAnalysis() {
            if (!tracker.state.themeAnalysis) {
                alert('Please run theme analysis first');
                return;
            }
            
            const validation = tracker.state.themeAnalysis.validation;
            const container = document.getElementById('theme-validation');
            
            let html = '<div class="validation-status">';
            html += `<div class="validation-indicator ${validation.valid ? 'valid' : 'invalid'}">`;
            html += validation.valid ? '✓ All validations passed' : '⚠ Issues detected';
            html += '</div></div>';
            
            container.innerHTML = html;
        }
        
        function displayThemeDebug() {
            console.log('Theme Analysis Debug:', tracker.state.themeAnalysis);
            alert('Check console for detailed theme analysis debug information');
        }
        
        function runScenarioAnalysis() {
            if (!tracker.state.themeAnalysis || !tracker.state.themeAnalysis.scenarios) {
                alert('Please complete theme analysis first (Step 3)');
                return;
            }
            
            const scenarios = tracker.state.themeAnalysis.scenarios;
            tracker.state.scenarioAnalysis = scenarios;
            tracker.saveState();
            
            displayScenarioMatrix(scenarios);
            
            if (!tracker.completedSteps.includes(4)) {
                tracker.completedSteps.push(4);
            }
        }
        
        function displayScenarioMatrix(scenarios) {
            const container = document.getElementById('scenario-results');
            const orderedScenarios = [...scenarios].sort((a, b) => a.id - b.id);
            
            let html = `
                <div class="scenario-matrix">
                    <h4>16-Scenario Probability Matrix</h4>
                    <div class="scenario-grid">
            `;
            
            orderedScenarios.forEach(scenario => {
                const percentage = (scenario.probability * 100).toFixed(2);
                let colorClass = 'scenario-very-low';
                
                if (scenario.probability > 0.10) {
                    colorClass = 'scenario-high';
                } else if (scenario.probability >= 0.05) {
                    colorClass = 'scenario-medium';
                } else {
                    colorClass = 'scenario-low';
                }
                
                html += `
                    <div class="scenario-item ${colorClass}">
                        <div class="scenario-rank">S${scenario.id}</div>
                        <div class="scenario-name">${scenario.name}</div>
                        <div class="scenario-probability">${percentage}%</div>
                        <div class="scenario-binary">${scenario.binary}</div>
                    </div>
                `;
            });
            
            html += `</div></div>`;
            container.innerHTML = html;
        }
        
        function validateScenarioMatrix() {
            if (!tracker.state.scenarioAnalysis) {
                alert('Please run scenario analysis first');
                return;
            }
            
            const scenarios = tracker.state.scenarioAnalysis;
            const totalProbability = scenarios.reduce((sum, s) => sum + s.probability, 0);
            
            const validationMessage = Math.abs(totalProbability - 1.0) < 0.01 ? 
                '✅ Scenario probabilities sum to 100%' : 
                '⚠ Scenario probabilities do not sum to 100%';
            
            alert(`${validationMessage}\nTotal: ${(totalProbability*100).toFixed(2)}%`);
        }
        
        function runPortfolioOptimization() {
            if (!tracker.state.scenarioAnalysis) {
                alert('Please complete scenario analysis first (Step 4)');
                return;
            }
            
            const results = PortfolioOptimizer.optimizePortfolio(tracker.state.scenarioAnalysis);
            
            if (results.performance.success) {
                tracker.state.optimizationResults = results;
                tracker.saveState();
                
                displayOptimizationResults(results);
                
                if (!tracker.completedSteps.includes(5)) {
                    tracker.completedSteps.push(5);
                }
                
                console.log('Portfolio optimization completed:', results);
            } else {
                alert('Optimization failed: ' + results.performance.error);
            }
        }
        
        function displayOptimizationResults(results) {
            const container = document.getElementById('optimization-results');
            const allocation = results.finalAllocation;
            const optimization = results.optimization;
            
            let html = `
                <div class="optimization-results">
                    <div class="optimization-header">
                        <h4>Portfolio Optimization Complete</h4>
                        <div class="analysis-meta">
                            ${results.framework} | Version ${results.version}
                        </div>
                    </div>
                    
                    <div class="optimization-summary">
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <div class="metric-value">${optimization.selectedScenarios}</div>
                                <div class="metric-label">Scenarios Used</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${(optimization.cumulativeProbability*100).toFixed(1)}%</div>
                                <div class="metric-label">Coverage</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="allocation-display">
                        <h4>Final Portfolio Allocation</h4>
            `;
            
            const sortedAllocations = Object.entries(allocation)
                .sort(([,a], [,b]) => b - a)
                .filter(([,weight]) => weight > 0.005);
            
            sortedAllocations.forEach(([security, weight]) => {
                const securityInfo = PortfolioOptimizer.securities[security];
                const percentage = (weight * 100).toFixed(1);
                const barWidth = Math.max(2, weight * 300);
                
                html += `
                    <div class="allocation-row">
                        <div class="security-info">
                            <div class="security-name">${security}</div>
                            <div class="security-desc">${securityInfo?.name || 'Unknown'}</div>
                        </div>
                        <div class="allocation-viz">
                            <div class="allocation-bar">
                                <div class="allocation-fill" style="width: ${barWidth}px; background: #007bff;"></div>
                            </div>
                            <div class="allocation-text">${percentage}%</div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div></div>';
            container.innerHTML = html;
        }
        
        function testOptimizationEdgeCases() {
            console.log('Testing portfolio optimization edge cases...');
            
            const extremeScenarios = [
                {id: 16, binary: '1111', name: 'All Themes Active', probability: 0.8},
                {id: 1, binary: '0000', name: 'Base Case', probability: 0.2}
            ];
            
            try {
                const results = PortfolioOptimizer.optimizePortfolio(extremeScenarios);
                console.log('Edge case test completed:', results);
                alert('Edge case test passed - see console for details');
            } catch (error) {
                console.error('Edge case test failed:', error);
                alert('Edge case test failed: ' + error.message);
            }
        }
        
        function validateOptimizationResults() {
            if (!tracker.state.optimizationResults) {
                alert('Please run optimization first');
                return;
            }
            
            const allocation = tracker.state.optimizationResults.finalAllocation;
            const total = Object.values(allocation).reduce((sum, weight) => sum + weight, 0);
            const validationMessage = Math.abs(total - 1.0) < 0.01 ? 
                '✅ Allocation sums to 100%' : 
                '⚠ Allocation does not sum to 100%';
            
            alert(`${validationMessage}\nTotal: ${(total*100).toFixed(2)}%`);
        }
        
        function runCompleteWorkflow() {
            console.log('Running complete workflow...');
            
            document.getElementById('philosophy-checkbox').checked = true;
            handlePhilosophyChange(true);
            
            setTimeout(() => {
                generateAndLoadSampleData('tech_boom');
                
                setTimeout(() => {
                    runThemeAnalysis();
                    
                    setTimeout(() => {
                        runScenarioAnalysis();
                        
                        setTimeout(() => {
                            runPortfolioOptimization();
                            tracker.navigateToStep(5);
                            console.log('Complete workflow finished');
                            alert('Complete workflow finished successfully!');
                        }, 500);
                    }, 500);
                }, 500);
            }, 500);
        }
        
        function handlePhilosophyChange(acknowledged) {
            tracker.state.philosophyAcknowledged = acknowledged;
            
            if (acknowledged && !tracker.completedSteps.includes(1)) {
                tracker.completedSteps.push(1);
            }
            
            tracker.saveState();
            console.log('Philosophy acknowledged:', acknowledged);
        }
        
        function saveIndicatorEdit() {
            if (DataEditor.saveIndicatorEdit) {
                const success = DataEditor.saveIndicatorEdit(tracker.state, () => {
                    displayDataTable(tracker.state.monthlyData);
                });
                
                if (success) {
                    tracker.saveState();
                }
            }
        }
        
        function exportState() {
            tracker.exportState();
        }
        
        function resetTracker() {
            if (confirm('Are you sure you want to reset all data?')) {
                tracker.reset();
                location.reload();
            }
        }
        
        function displayDebugInfo() {
            const debugInfo = tracker.getDebugInfo ? tracker.getDebugInfo() : {
                state: tracker.state,
                completedSteps: tracker.completedSteps,
                currentStep: tracker.currentStep
            };
            
            console.log('Debug Info:', debugInfo);
            alert('Debug information logged to console');
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing Integration Test v3.5.1...');
            
            if (typeof tracker.init === 'function') {
                tracker.init();
            }
            
            if (typeof tracker.loadState === 'function') {
                tracker.loadState();
            }
            
            tracker.navigateToStep(1);
            
            if (DataEditor && DataEditor.setupModalListeners) {
                DataEditor.setupModalListeners();
            }
            
            console.log('Integration Test v3.5.1 initialized successfully');
            console.log('Modules embedded:', {
                TrackerCore: TrackerCore.version,
                FileHandler: FileHandler.version,
                ThemeCalculator: ThemeCalculator.version,
                DataEditor: DataEditor.version,
                Indicators: Indicators.version,
                PortfolioOptimizer: PortfolioOptimizer.version
            });
            
            runModuleTests();
        });
    </script>
</body>
</html>